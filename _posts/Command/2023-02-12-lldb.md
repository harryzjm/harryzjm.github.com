---  
layout: post  
title: LLDB Command  
category: Command  
tags: LLDB  
keywords: LLDB  
---  

__Posted by [Airths](https://blog.csdn.net/Airths/article/details/122457564)__  


# 本文所使用的 LLDB 版本

```bash
(lldb) version
lldb-1200.0.44.2
Apple Swift version 5.3.2 (swiftlang-1200.0.45 clang-1200.0.32.28)
```

# \_regexp-attach

```bash
(lldb) help _regexp-attach
     # 根据指定的进程 ID 或进程名称，附加到指定的进程
     # 期望使用原始输入(请参阅 'help raw-input')

Syntax: _regexp-attach <pid> | <process-name>
```

# \_regexp-break

```bash
(lldb) help _regexp-break
     # 使用以下几种速记格式之一设置断点
     # 期望使用原始输入(请参阅 'help raw-input')

Syntax:
_regexp-break <filename>:<linenum>
              main.c:12             # 在 main.c 文件的第 12 行设置断点

_regexp-break <linenum>
              12                    # 在当前文件的第 12 行设置断点

_regexp-break 0x<address>
              0x1234000             # 在内存地址 0x1234000 处设置断点

_regexp-break <name>
              main                  # 在名为 main 的函数上设置断点

_regexp-break &<name>
              &main                 # 在名为 main 的函数的第一条汇编指令处设置断点

_regexp-break <module>`<name>
              libc.so`malloc        # 在 libc.so 库中名为 malloc 的函数上设置断点

_regexp-break /<source-regex>/
              /break here/          # 在当前源文件中包含文本 break here 的行设置断点
```

# \_regexp-bt

```bash
(lldb) help _regexp-bt
     # 显示当前线程的调用栈
     # 数字参数用于指定要显示的帧数，all 参数用于指定显示所有线程的调用栈
     # 期望使用原始输入(请参阅 'help raw-input')

Syntax: bt [<digit> | all]
```

# \_regexp-display

```bash
(lldb) help _regexp-display
     # 在每次程序暂停时，执行指定的表达式(请参阅 'help target stop-hook')
     # 期望使用原始输入(请参阅 'help raw-input')

Syntax: _regexp-display expression
```

# \_regexp-down

```bash
(lldb) help _regexp-down
     # 选择一个较新的栈帧
     # 默认情况下移动一帧，指定数字参数以控制要移动的帧数
     # 期望使用原始输入(请参阅 'help raw-input')

Syntax: _regexp-down [<count>]
```

# \_regexp-env

```bash
(lldb) help _regexp-env
     # 用于查看和设置环境变量
     # 期望使用原始输入(请参阅 'help raw-input')

Syntax:
_regexp-env                  # 查看环境变量
_regexp-env <name>=<value>   # 设置环境变量
```

# \_regexp-jump

```bash
(lldb) help _regexp-jump
     # 将程序计数器(PC 寄存器)设置为新地址
     # 期望使用原始输入(请参阅 'help raw-input')

Syntax:
_regexp-jump <line>
_regexp-jump +<line-offset> | -<line-offset>
_regexp-jump <file>:<line>
_regexp-jump *<addr>
```

# \_regexp-list

```bash
(lldb) help _regexp-list
     # 使用以下几种速记格式之一列出相关源代码
     # 期望使用原始输入(请参阅 'help raw-input')

Syntax:
_regexp-list <file>:<line>   # 列出指定文件中指定行号处的源代码
_regexp-list <line>          # 列出当前文件中指定行号处的源代码
_regexp-list <function-name> # 列出指定函数的源代码
_regexp-list 0x<address>     # 列出指定内存地址处的源代码
_regexp-list -[<count>]      # 列出前 <count> 行的源代码
_regexp-list                 # 列出后续行的源代码
```

# \_regexp-tbreak

```bash
(lldb) help _regexp-tbreak
     # 使用以下几种速记格式之一设置一次性断点
     # 期望使用原始输入(请参阅 'help raw-input')

Syntax:
_regexp-tbreak <filename>:<linenum>
               main.c:12             # 在 main.c 文件的第 12 行设置一次性断点

_regexp-tbreak <linenum>
               12                    # 在当前文件的第 12 行设置一次性断点

_regexp-tbreak 0x<address>
               0x1234000             # 在内存地址 0x1234000 处设置一次性断点

_regexp-tbreak <name>
               main                  # 在名为 main 的函数上设置一次性断点

_regexp-tbreak &<name>
               &main                 # 在名为 main 的函数的第一条汇编指令处设置一次性断点

_regexp-tbreak <module>`<name>
               libc.so`malloc        # 在 libc.so 库中名为 malloc 的函数上设置一次性断点

_regexp-tbreak /<source-regex>/
               /break here/          # 在当前源文件中包含文本 break here 的行设置一次性断点
```

# \_regexp-undisplay

```bash
(lldb) help _regexp-undisplay
     # 停止执行指定的 stop-hook (通过 stop-hook 索引指定，请参阅 'help target stop-hook')
     # 期望使用原始输入(请参阅 'help raw-input')

Syntax: _regexp-undisplay stop-hook-number
```

# \_regexp-up

```bash
(lldb) help _regexp-up
     # 选择一个较旧的栈帧
     # 默认情况下移动一帧，指定数字参数以控制要移动的帧数
     # 期望使用原始输入(请参阅 'help raw-input')

Syntax: _regexp-up [<count>]
```

# apropos

```bash
(lldb) help apropos
     # 用于列出与给定单词或给定主题相关的调试命令

Syntax: apropos <search-word>
```

# breakpoint

```bash
(lldb) help breakpoint
     # 用于操作断点的命令(请参阅 'help b' 以查看速记格式)

Syntax: breakpoint <subcommand> [<command-options>]

The following subcommands are supported:

      clear      # 删除或禁用与指定的源文件和行号相匹配的断点
      command    # 用于添加、删除和列出在命中断点时执行的 LLDB 命令的命令
      delete     # 删除指定的断点
      			 # 如果没有指定任何断点，则将所有断点全部删除
      disable    # 禁用指定的断点，而不删除它们
      			 # 如果没有指定任何断点，则将所有断点全部禁用
      enable     # 启用指定的断点
      			 # 如果没有指定任何断点，则将所有断点全部启用
      list       # 以可配置的详细程度列出部分或全部断点
      modify  	 # 修改可执行文件中一个或一组断点上的选项
				 # 如果没有指定任何断点，则修改最后创建的断点
				 # 除了 -e, -d, -i 之外，传递一个空的参数可以清除已做的修改
      name       # 用于管理断点的名称标记的命令
      read    	 # 读取并设置之前通过 "breakpoint write" 命令保存到文件中的断点
      set     	 # 在可执行文件中设置一个或一组断点
      write      # 将列出的断点写入到一个可以通过 "breakpoint read" 命令读取的文件中
      			 # 如果没有指定任何参数，则会写入所有的断点

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

## breakpoint clear

```bash
(lldb) help breakpoint clear
     # 删除或禁用与指定的源文件和行号相匹配的断点

Syntax: breakpoint clear <cmd-options>

Command Options Usage:
  breakpoint clear -l <linenum> [-f <filename>]

       -f <filename> ( --file <filename> )
            # 在此特定文件按源位置指定断点

       -l <linenum> ( --line <linenum> )
            # 在此特定行按源位置指定断点
```

## breakpoint command

```bash
(lldb) help breakpoint command
      # 用于添加、删除和列出在命中断点时执行的 LLDB 命令的命令

Syntax: command <sub-command> [<sub-command-options>] <breakpoint-id>

The following subcommands are supported:

      add       # 将 LLDB 命令添加到断点中，以便在命中断点时执行
      			# 如果没有指定任何断点，则将这些命令添加到最后一个创建的断点中
      delete 	# 从指定的断点中删除已添加的 LLDB 命令
      list   	# 列出在命中断点时要执行的脚本或命令

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

### breakpoint command add

```bash
(lldb) help breakpoint command add
     # 将 LLDB 命令添加到断点中，以便在命中断点时执行
     # 如果没有指定任何断点，则将这些命令添加到最后一个创建的断点中

Syntax: breakpoint command add <cmd-options> [<breakpt-id>]

Command Options Usage:
  breakpoint command add [-D] [-o <one-line-command>] [-s <none>] [-e <boolean>] [<breakpt-id>]
  breakpoint command add [-D] -F <python-function> [-s <none>] [-e <boolean>] [-k <none>] [-v <none>] [<breakpt-id>]

       -D ( --dummy-breakpoints )
            # 设置虚拟断点
            # 例如: 在提供文件之前设置的断点，主要用于新的 target

       -F <python-function> ( --python-function <python-function> )
            # 要管理断点命令的函数的名称

       -e <boolean> ( --stop-on-error <boolean> )
            # 指定断点命令是否应在错误时终止执行

       -k <none> ( --structured-data-key <none> )
       		# 传递给断点命令的实现的键值对的键
       		# 键值对可以被指定多次

       -o <one-line-command> ( --one-liner <one-line-command> )
            # 指定内联的断点命令
            # 该命令一定要用引号括起来

       -s <none> ( --script-type <none> )
            # 指定命令的语言，如果没有指定任何语言，则使用 LLDB 命令解释器
            # 可用值: command | python | lua | default-script

       -v <none> ( --structured-data-value <none> )
            # 传递给断点命令的实现的键值对的值(对应前一个键)
            # 键值对可以被指定多次

# 关于输入断点命令的一般信息
------------------------------------------------------

# 此命令将在命中指定断点时提示要执行的命令
# 每个命令都在 '> ' 提示符后在自己的行上输入，直到输入 'DONE' 结束

# 在输入时可能无法检测到语法错误，并且许多格式错误的命令在执行时可能会默默地失败
# 如果断点命令似乎没有被执行，则请仔细检查命令语法

# 注意:
# 完全可以按照在 debugger prompt 中的输入方式输入任何调试命令(Xcode 的调试区域就是一个 debugger prompt)
# 输入的命令数量没有限制，但是不要在每行输入一个以上的命令

# 有关 Python 断点命令的特殊信息
----------------------------------------------------

# 你可以输入一行或多行 Python，包括函数定义，或对(在代码执行时已导入的函数)的调用
# 当断点被命中时，单行断点命令将被 "按原样" 解释
# 多行 Python 代码将包装在生成的函数中，对该函数的调用将被附加到断点上

# 这个自动生成的函数传入三个参数:
# frame:  表示被命中的断点的帧的 lldb.SBFrame 对象
# bp_loc: 表示被命中的断点位置的 lldb.SBBreakpointLocation 对象
# dict:   表示 Python 会话字典

# 当使用 --python-function 选项指定 Python 函数时，需要提供以模块名称开头的函数名称:
    --python-function myutils.breakpoint_callback

# 该函数本身必须具备以下函数原型:
def breakpoint_callback(frame, bp_loc, dict):
  # Your code goes here

# 这里的参数与上述传递给自动生成的函数的参数相同
# 请注意，因为调用此函数时不会更新全局变量 'lldb.frame'，所以请务必使用 'frame' 参数
# 'frame' 参数可以通过 frame.GetThread() 获取线程，线程可以通过 thread.GetProcess() 获取进程，进程可以通过 process.GetTarget() 获取 target

# 重要提示:
# 随着 Python 代码被收集到自动生成的函数中，访问全局变量时需要使用 'global' 关键字显式指定作用域
# 输入 Python 断点命令时，请务必使用正确的 Python 语法，包括缩进

# Python 单行断点命令的示例:

(lldb) breakpoint command add -s python 1
Enter your Python command(s). Type 'DONE' to end.
> print "Hit this breakpoint!"
> DONE

# 为了方便起见，这也适用于短的单行断点命令:

(lldb) breakpoint command add -s python 1 -o 'import time; print time.asctime()'
(lldb) run
Launching '.../a.out'  (x86_64)
(lldb) Fri Sep 10 12:17:45 2010
Process 21778 Stopped
* thread #1: tid = 0x2e03, 0x0000000100000de8 a.out`c + 7 at main.c:39, stop
reason = breakpoint 1.1, queue = com.apple.main-thread
  36
  37   	int c(int val)
  38   	{
  39 ->	    return val + 3;
  40   	}
  41
  42   	int main (int argc, char const *argv[])

# 多行 Python 断点命令的示例:

(lldb) breakpoint command add -s p 1
Enter your Python command(s). Type 'DONE' to end.
> global bp_count
> bp_count = bp_count + 1
> print "Hit this breakpoint " + repr(bp_count) + " times!"
> DONE

# Python 多行命令的示例(使用函数定义):

(lldb) breakpoint command add -s python 1
Enter your Python command(s). Type 'DONE' to end.
> def breakpoint_output (bp_no):
>     out_string = "Hit breakpoint number " + repr (bp_no)
>     print out_string
>     return True
> breakpoint_output (1)
> DONE

# 在这种情况下，因为存在对全局变量 'bp_count' 的引用，所以你还需要确保全局变量 'bp_count' 存在并已初始化:

(lldb) script
>>> bp_count = 0
>>> quit()

# 无论你的 Python 代码如何组织，都可以选择返回一个值
# 如果返回值为 False，则告诉 LLDB 不要在代码关联的断点处暂停
# 返回 False 以外的任何内容，甚至返回 None，甚至完全省略 return 语句，都会导致 LLDB 暂停

# 最后说明:
# 当没有语法错误时，出现没有生成断点命令的警告，可能表明函数已经声明但是从未被调用

----------------------------------------------------

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

### breakpoint command delete

```bash
(lldb) help breakpoint command delete
     # 从指定的断点中删除已添加的 LLDB 命令

Syntax: breakpoint command delete <cmd-options> <breakpt-id>

Command Options Usage:
  breakpoint command delete [-D] <breakpt-id>

       -D ( --dummy-breakpoints )
            # 从虚拟断点中删除已添加的 LLDB 命令
            # 例如: 在提供文件之前设置的断点，主要用于新的 target

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

### breakpoint command list

```bash
(lldb) help breakpoint command list
     # 列出在命中断点时要执行的脚本或命令

Syntax: breakpoint command list <breakpt-id>
```

## breakpoint delete

```bash
(lldb) help breakpoint delete
     # 删除指定的断点
     # 如果没有指定任何断点，则将所有断点全部删除

Syntax: breakpoint delete <cmd-options> [<breakpt-id | breakpt-id-list>]

Command Options Usage:
  breakpoint delete [-Df] [<breakpt-id | breakpt-id-list>]

       -D ( --dummy-breakpoints )
            # 删除虚拟断点
            # 例如: 在提供文件之前设置的断点，主要用于新的 target

       -f ( --force )
            # 删除所有断点，而不查询确认

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

## breakpoint disable

```bash
(lldb) help breakpoint disable
     # 禁用指定的断点，而不删除它们
     # 如果没有指定任何断点，则将所有断点全部禁用

Syntax: breakpoint disable [<breakpt-id | breakpt-id-list>]

# 注意:
# 无论断点的单个位置是启用还是禁用，禁用断点后都不会导致该断点的任何位置被命中

# 执行如下命令后，程序运行将不会暂停在 1.1 所标识的位置:
(lldb) break disable 1
(lldb) break enable 1.1

# 要实现程序运行暂停在 1.1 所标识的位置，请输入:
# 第一条命令禁用断点 1 的所有位置，第二条命令重新启用断点 1 的第 1 个位置
(lldb) break disable 1.*
(lldb) break enable 1.1
```

## breakpoint enable

```bash
(lldb) help breakpoint enable
     # 启用指定的断点
     # 如果没有指定任何断点，则将所有断点全部启用

Syntax: breakpoint enable [<breakpt-id | breakpt-id-list>]
```

## breakpoint list

```bash
(lldb) help breakpoint list
     # 以可配置的详细程度列出部分或全部断点

Syntax: breakpoint list <cmd-options> [<breakpt-id>]

Command Options Usage:
  breakpoint list [-Dbi] [<breakpt-id>]
  breakpoint list [-Dfi] [<breakpt-id>]
  breakpoint list [-Div] [<breakpt-id>]

       -D ( --dummy-breakpoints )
            # 列出虚拟断点
            # 例如: 在提供文件之前设置的断点，主要用于新的 target

       -b ( --brief )
            # 提供对断点的简要描述(没有位置信息)

       -f ( --full )
            # 提供对断点及其位置信息的完整描述

       -i ( --internal )
            # 显示调试器的内部断点

       -v ( --verbose )
            # 解释我们所知道的关于断点的一切(用于调试调试器的 bug)

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

## breakpoint modify

```bash
(lldb) help breakpoint modify
     # 修改可执行文件中一个或一组断点上的选项
     # 如果没有指定任何断点，则修改最后创建的断点
	 # 除了 -e, -d, -i 之外，传递一个空的参数可以清除已做的修改

Syntax: breakpoint modify <cmd-options> [<breakpt-id | breakpt-id-list>]

Command Options Usage:
  breakpoint modify [-Dde] [-G <boolean>] [-c <expr>] [-i <count>] [-o <boolean>] [-q <queue-name>] [-t <thread-id>] [-x <thread-index>] [-T <thread-name>] [<breakpt-id | breakpt-id-list>]

       -D ( --dummy-breakpoints )
            # 修改虚拟断点
            # 例如: 在提供文件之前设置的断点，主要用于新的 target

       -G <boolean> ( --auto-continue <boolean> )
            # 断点将在运行其命令后自动继续运行

       -T <thread-name> ( --thread-name <thread-name> )
            # 断点仅针对线程名称与此参数匹配的线程暂停

       -c <expr> ( --condition <expr> )
            # 仅当此条件表达式的计算结果为 true 时，断点才会暂停

       -d ( --disable )
            # 禁用断点

       -e ( --enable )
            # 启用断点

       -i <count> ( --ignore-count <count> )
            # 设置在命中断点之前，跳过此断点的次数

       -o <boolean> ( --one-shot <boolean> )
            # 一次性断点
            # 在第一次命中该断点而暂停时，该断点将被删除

       -q <queue-name> ( --queue-name <queue-name> )
            # 断点仅针对队列名称与此参数匹配的线程暂停

       -t <thread-id> ( --thread-id <thread-id> )
            # 断点仅针对线程 ID 与此参数匹配的线程暂停

       -x <thread-index> ( --thread-index <thread-index> )
            # 断点仅针对线程索引与此参数匹配的线程暂停

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

## breakpoint name

```bash
(lldb) help breakpoint name
     # 用于管理断点的名称标记的命令

Syntax: breakpoint name <subcommand> [<command-options>]

The following subcommands are supported:

      add          # 向指定的断点添加一个名称
      configure    # 为指定的断点名称配置选项
      			   # 如果你提供了一个断点 ID，则将从该断点复制这些配置选项，否则将只在该名称上设置指定的配置选项
      delete       # 从指定的断点中删除断点名称
      list         # 列出断点名称或有关给定断点名称的信息
      			   # 如果不带参数，则列出所有断点名称

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

### breakpoint name add

```bash
(lldb) help breakpoint name add
     # 向指定的断点添加一个名称

Syntax: breakpoint name add <command-options> <breakpoint-id-list>

Command Options Usage:
  add [-N <breakpoint-name>] [<breakpt-id>]

       -N <breakpoint-name> ( --name <breakpoint-name> )
            # 指定要使用的断点名称

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

### breakpoint name configure

```bash
(lldb) help breakpoint name configure
     # 为指定的断点名称配置选项
     # 如果你提供了一个断点 ID，则将从该断点复制这些配置选项，否则将只在该名称上设置指定的配置选项

Syntax: breakpoint name configure <command-options> <breakpoint-name-list>

Command Options Usage:
  configure [-de] [-G <boolean>] [-C <command>] [-c <expr>] [-i <count>] [-o <boolean>] [-q <queue-name>] [-t <thread-id>] [-x <thread-index>] [-T <thread-name>] [-D <boolean>] [-A <boolean>] [-L <boolean>] [-B <breakpt-id>] [-H <none>] [<breakpoint-name>]

       -A <boolean> ( --allow-disable <boolean> )
            # 确定是否可以按名称禁用该断点，或在禁用所有断点时禁用该断点

       -B <breakpt-id> ( --breakpoint-id <breakpt-id> )
            # 指定要使用的断点 ID

       -C <command> ( --command <command> )
            # 当命中断点时要运行的命令，可以多次重复此选项以指定多条命令，这些命令将按从左到右的顺序运行

       -D <boolean> ( --allow-delete <boolean> )
            # 确定是否可以按名称删除该断点，或在删除所有断点时删除该断点

       -G <boolean> ( --auto-continue <boolean> )
            # 断点将在运行其命令后自动继续运行

       -H <none> ( --help-string <none> )
            # 描述此断点名称用途的帮助字符串

       -L <boolean> ( --allow-list <boolean> )
            # 确定断点是否会显示在断点列表中(如果没有明确的引用)

       -T <thread-name> ( --thread-name <thread-name> )
            # 断点仅针对线程名称与此参数匹配的线程暂停

       -c <expr> ( --condition <expr> )
            # 仅当此条件表达式的计算结果为 true 时，断点才会暂停

       -d ( --disable )
            # 禁用断点

       -e ( --enable )
            # 启用断点

       -i <count> ( --ignore-count <count> )
            # 设置在命中断点之前，跳过此断点的次数

       -o <boolean> ( --one-shot <boolean> )
            # 一次性断点
            # 在第一次命中该断点而暂停时，该断点将被删除

       -q <queue-name> ( --queue-name <queue-name> )
            # 断点仅针对队列名称与此参数匹配的线程暂停

       -t <thread-id> ( --thread-id <thread-id> )
            # 断点仅针对线程 ID 与此参数匹配的线程暂停

       -x <thread-index> ( --thread-index <thread-index> )
            # 断点仅针对线程索引与此参数匹配的线程暂停

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

### breakpoint name delete

```bash
(lldb) help breakpoint name delete
     # 从指定的断点中删除断点名称

Syntax: breakpoint name delete <command-options> <breakpoint-id-list>

Command Options Usage:
  delete [-N <breakpoint-name>] [<breakpt-id>]

       -N <breakpoint-name> ( --name <breakpoint-name> )
            # 指定要使用的断点名称

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

### breakpoint name list

```bash
(lldb) help breakpoint name list
     # 列出断点名称或有关给定断点名称的信息
     # 如果不带参数，则列出所有断点名称

Syntax: breakpoint name list <command-options>

Command Options Usage:
  list [-D]

       -D ( --dummy-breakpoints )
            # 在虚拟断点上进行操作
            # 例如: 在提供文件之前设置的断点，主要用于新的 target
```

## breakpoint read

```bash
(lldb) help breakpoint read
     # 读取并设置之前通过 "breakpoint write" 命令保存到文件中的断点

Syntax: breakpoint read <cmd-options> [<breakpt-id | breakpt-id-list>]

Command Options Usage:
  breakpoint read -f <filename> [-N <breakpoint-name>] [<breakpt-id | breakpt-id-list>]

       -N <breakpoint-name> ( --breakpoint-name <breakpoint-name> )
            # 仅读取具有此断点名称的断点

       -f <filename> ( --file <filename> )
            # 要从中读取断点的文件

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

## breakpoint set

```bash
(lldb) help breakpoint set
     # 在可执行文件中设置一个或一组断点

Syntax: breakpoint set <cmd-options>

Command Options Usage:
  breakpoint set [-DHd] -l <linenum> [-G <boolean>] [-C <command>] [-c <expr>] [-i <count>] [-o <boolean>] [-q <queue-name>] [-t <thread-id>] [-x <thread-index>] [-T <thread-name>] [-R <address>] [-N <breakpoint-name>] [-u <column>] [-f <filename>] [-m <boolean>] [-s <shlib-name>] [-K <boolean>]
  breakpoint set [-DHd] -a <address-expression> [-G <boolean>] [-C <command>] [-c <expr>] [-i <count>] [-o <boolean>] [-q <queue-name>] [-t <thread-id>] [-x <thread-index>] [-T <thread-name>] [-N <breakpoint-name>] [-s <shlib-name>]
  breakpoint set [-DHd] -n <function-name> [-G <boolean>] [-C <command>] [-c <expr>] [-i <count>] [-o <boolean>] [-q <queue-name>] [-t <thread-id>] [-x <thread-index>] [-T <thread-name>] [-R <address>] [-N <breakpoint-name>] [-f <filename>] [-L <source-language>] [-s <shlib-name>] [-K <boolean>]
  breakpoint set [-DHd] -F <fullname> [-G <boolean>] [-C <command>] [-c <expr>] [-i <count>] [-o <boolean>] [-q <queue-name>] [-t <thread-id>] [-x <thread-index>] [-T <thread-name>] [-R <address>] [-N <breakpoint-name>] [-f <filename>] [-L <source-language>] [-s <shlib-name>] [-K <boolean>]
  breakpoint set [-DHd] -S <selector> [-G <boolean>] [-C <command>] [-c <expr>] [-i <count>] [-o <boolean>] [-q <queue-name>] [-t <thread-id>] [-x <thread-index>] [-T <thread-name>] [-R <address>] [-N <breakpoint-name>] [-f <filename>] [-L <source-language>] [-s <shlib-name>] [-K <boolean>]
  breakpoint set [-DHd] -M <method> [-G <boolean>] [-C <command>] [-c <expr>] [-i <count>] [-o <boolean>] [-q <queue-name>] [-t <thread-id>] [-x <thread-index>] [-T <thread-name>] [-R <address>] [-N <breakpoint-name>] [-f <filename>] [-L <source-language>] [-s <shlib-name>] [-K <boolean>]
  breakpoint set [-DHd] -r <regular-expression> [-G <boolean>] [-C <command>] [-c <expr>] [-i <count>] [-o <boolean>] [-q <queue-name>] [-t <thread-id>] [-x <thread-index>] [-T <thread-name>] [-R <address>] [-N <breakpoint-name>] [-f <filename>] [-L <source-language>] [-s <shlib-name>] [-K <boolean>]
  breakpoint set [-DHd] -b <function-name> [-G <boolean>] [-C <command>] [-c <expr>] [-i <count>] [-o <boolean>] [-q <queue-name>] [-t <thread-id>] [-x <thread-index>] [-T <thread-name>] [-R <address>] [-N <breakpoint-name>] [-f <filename>] [-L <source-language>] [-s <shlib-name>] [-K <boolean>]
  breakpoint set [-ADHd] -p <regular-expression> [-G <boolean>] [-C <command>] [-c <expr>] [-i <count>] [-o <boolean>] [-q <queue-name>] [-t <thread-id>] [-x <thread-index>] [-T <thread-name>] [-N <breakpoint-name>] [-f <filename>] [-m <boolean>] [-s <shlib-name>] [-X <function-name>]
  breakpoint set [-DHd] -E <source-language> [-G <boolean>] [-C <command>] [-c <expr>] [-i <count>] [-o <boolean>] [-q <queue-name>] [-t <thread-id>] [-x <thread-index>] [-T <thread-name>] [-N <breakpoint-name>] [-O <type-name>] [-h <boolean>] [-w <boolean>]
  breakpoint set [-DHd] -P <python-class> [-k <none>] [-v <none>] [-G <boolean>] [-C <command>] [-c <expr>] [-i <count>] [-o <boolean>] [-q <queue-name>] [-t <thread-id>] [-x <thread-index>] [-T <thread-name>] [-N <breakpoint-name>] [-f <filename>] [-s <shlib-name>]

       -A ( --all-files )
            # 搜索所有文件以查找源模式匹配项

       -C <command> ( --command <command> )
            # 当命中断点时要运行的命令，可以多次重复此选项以指定多条命令，这些命令将按从左到右的顺序运行

       -D ( --dummy-breakpoints )
            # 作用于虚拟断点
            # 例如: 在提供文件之前设置的断点，主要用于新的 target

       -E <source-language> ( --language-exception <source-language> )
            # 在指定语言抛出的异常上设置断点(如果不带此选项，则会抛出异常但不会捕获异常)

       -F <fullname> ( --fullname <fullname> )
            # 通过完全限定的函数名称设置断点
            # 对于 C++ 而言，这意味着命名空间和所有参数
            # 对于 Objective-C 而言，这意味着具有类名和方法选择器的完整函数原型
			# 可以多次重复此选项，为多个函数名称创建一个断点

       -G <boolean> ( --auto-continue <boolean> )
            # 断点将在运行其命令后自动继续运行

       -H ( --hardware )
            # 要求断点使用硬件断点

       -K <boolean> ( --skip-prologue <boolean> )
            # 如果断点位于函数的开头，则跳过 Function Prologue
            # 如果没有设置，则使用 target.skip-prologue 的设置

       -L <source-language> ( --language <source-language> )
            # 指定在解释断点表达式时要使用的语言(注意: 目前仅用于在标识符上设置断点)
            # 如果没有设置，则使用 target.language 的设置

       -M <method> ( --method <method> )
            # 通过 C++ 方法名称设置断点
            # 可以多次重复此选项，为多个 C++ 方法名称创建一个断点

       -N <breakpoint-name> ( --breakpoint-name <breakpoint-name> )
            # 将此参数添加到此断点的断点名称列表中
            # 即，为此断点添加一个断点名称

       -O <type-name> ( --exception-typename <type-name> )
            # 只有在抛出此种类型的异常对象时，断点才会暂停
            # 可以多次重复此选项，以针对多种异常对象的类型
            # 如果只指定异常类型的基本名称，则它将与所有模块中的该异常类型匹配，或可以指定包括模块名称在内的完整类型名称
            # 其他子匹配暂不支持
            # 目前仅支持 Swift

       -P <python-class> ( --script-class <python-class> )
            # 将管理脚本化断点的类的名称

       -R <address> ( --address-slide <address> )
            # 将指定的偏移量添加到断点解析到的任何地址
            # 目前，会直接应用给定的偏移量，并且不会尝试将其与指令边界对齐

       -S <selector> ( --selector <selector> )
            # 通过 ObjC 方法选择器的名称设置断点
            # 可以多次重复此选项，为多个 ObjC 方法选择器创建一个断点

       -T <thread-name> ( --thread-name <thread-name> )
            # 断点仅针对线程名称与此参数匹配的线程暂停

       -X <function-name> ( --source-regexp-function <function-name> )
            # 当与 '-p' 一起使用时，将源正则表达式限制为包含在命名函数中的源
            # 可以多次重复此选项

       -a <address-expression> ( --address <address-expression> )
            # 在指定的地址设置断点
            # 如果指定的地址被唯一地映射到特定的二进制文件，则该地址将被转换为文件地址，以便无论该二进制文件最终被加载到何处，断点都能通过跟踪(二进制文件+偏移量)的方式进行解析
            # 或者，如果你还通过了 -s 选项指定了模块，则该指定的地址将被视为该模块中的文件地址，并相应的进行解析
            # 同样，这将允许 LLDB 在后续重新加载时跟踪该偏移量以进行解析
			# 在你创建此断点时，该模块不需要已经加载，断点将在该模块加载时得到解析

       -b <function-name> ( --basename <function-name> )
			# 通过函数的基本名称设置断点(C++ 命名空间和参数将被忽略)
			# 可以多次重复此选项，为多个符号创建一个断点

       -c <expr> ( --condition <expr> )
            # 仅当此条件表达式的计算结果为 true 时，断点才会暂停

       -d ( --disable )
             # 禁用断点

       -f <filename> ( --file <filename> )
       		# 指定要在其中设置断点的源文件
       		# 请注意，默认情况下 LLDB 仅查找使用标准包含文件扩展名的 #included 文件
       		# 要在 #included 的 .c/.cpp/.m/.mm 文件上设置断点，请将 target.inline-breakpoint-strategy 设置为 always

       -h <boolean> ( --on-catch <boolean> )
            # 在异常捕获时设置断点

       -i <count> ( --ignore-count <count> )
            # 设置在命中断点之前，跳过此断点的次数

       -k <none> ( --structured-data-key <none> )
            # 传递给脚本化断点实现的键值对的键
            # 键值对可以被指定多次

       -l <linenum> ( --line <linenum> )
       		# 指定要在其上设置断点的行号

       -m <boolean> ( --move-to-nearest-code <boolean> )
       		# 将断点移动到最近的代码
       		# 如果没有设置，则使用 target.move-to-nearest-codesetting 的设置

       -n <function-name> ( --name <function-name> )
       		# 通过函数名称设置断点
       		# 可以多次重复此选项，为多个函数名称创建一个断点

       -o <boolean> ( --one-shot <boolean> )
            # 一次性断点
            # 在第一次命中该断点而暂停时，该断点将被删除

       -p <regular-expression> ( --source-pattern-regexp <regular-expression> )
			# 通过指定与源文件中的源文本匹配的正则表达式来设置断点，或通过多次使用 -f 选项指定多个源文件
            # 如果未指定源文件，则使用当前默认的源文件
            # 如果要匹配所有源文件，则请传递 --all-files 选项

       -q <queue-name> ( --queue-name <queue-name> )
            # 断点仅针对队列名称与此参数匹配的线程暂停

       -r <regular-expression> ( --func-regex <regular-expression> )
            # 按函数名称设置断点，执行正则表达式以查找函数名称

       -s <shlib-name> ( --shlib <shlib-name> )
            # 仅在指定的共享库中设置断点
            # 可以多次重复此选项以指定多个共享库

       -t <thread-id> ( --thread-id <thread-id> )
            # 断点仅针对线程 ID 与此参数匹配的线程暂停

       -u <column> ( --column <column> )
            # 指定要在其上设置断点的列号

       -v <none> ( --structured-data-value <none> )
       		# 传递给脚本化断点实现的键值对的值
       		# 键值对可以被指定多次

       -w <boolean> ( --on-throw <boolean> )
            # 在异常抛出时设置断点

       -x <thread-index> ( --thread-index <thread-index> )
            # 断点仅针对线程索引与此参数匹配的线程暂停
```

## breakpoint write

```bash
(lldb) help breakpoint write
     # 将列出的断点写入到一个可以通过 "breakpoint read" 命令读取的文件中
     # 如果没有指定任何参数，则会写入所有的断点

Syntax: breakpoint write <cmd-options> [<breakpt-id | breakpt-id-list>]

Command Options Usage:
  breakpoint write [-a] -f <filename> [<breakpt-id | breakpt-id-list>]

       -a ( --append )
            # 拼接到已保存的断点文件(如果该文件存在的话)

       -f <filename> ( --file <filename> )
            # 要写入断点的文件

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

# command

```bash
(lldb) help command
     # 用于管理自定义 LLDB 命令的命令

Syntax: command <subcommand> [<subcommand-options>]

The following subcommands are supported:

      alias      # 根据现有的命令定义一个自定义命令(即，为现有的命令取一个别名)
                 # 期望使用原始输入(请参阅 'help raw-input')
      delete     # 删除一个或多个由 'command regex' 定义的自定义命令
      history    # 转储此会话中的命令历史记录
                 # 历史列表中的命令可以使用 "!<INDEX>" 再次运行
                 # "!-<OFFSET>" 将重新运行历史列表末尾偏移 <OFFSET> 处的命令(计算当前命令)
      regex      # 通过匹配正则表达式根据现有的命令定义一个自定义命令
      script     # 用于管理由解释器脚本实现的自定义命令的命令
      source     # 从文件 <filename> 读取和执行 LLDB 命令
      unalias    # 删除一个或多个由 'command alias' 定义的自定义命令

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

## command alias

```bash
(lldb) help command alias
     # 根据现有的命令定义一个自定义命令(即，为现有的命令取一个别名)
     # 期望使用原始输入(请参阅 'help raw-input')

Syntax: command alias <cmd-options> -- <alias-name> <cmd-name> [<options-for-aliased-command>]

Command Options Usage:
  command alias [-h <help-text>] [-H <help-text>] -- <alias-name> <cmd-name> [<options-for-aliased-command>]
  command alias <alias-name> <cmd-name> [<options-for-aliased-command>]

       -H <help-text> ( --long-help <help-text> )
            # 此命令别名的详细帮助文档

       -h <help-text> ( --help <help-text> )
            # 此命令别名的帮助文档

# 命令别名允许用户为: 长命令、多单词命令、拥有特定选项的命令，创建一个快捷方式或缩写
# 下面是一些关于如何使用 'command alias' 命令的简单示例:

# 为 'script' 命令创建命令别名 'sc'
(lldb) command alias sc script

# 为 'breakpoint' 命令创建命令别名 'bp'
# 因为 'breakpoint' 命令是多单词命令，所以用户仍然需要在 'bp' 之后输入第二个单词，例如:
# 'bp enable' 或 'bp delete'
(lldb) command alias bp breakpoint

# 为两个单词的命令 'breakpoint list' 创建命名别名 'bpl'
(lldb) command alias bpl breakpoint list

# 命令别名可以包含该命令的一些选项，这些选项的值可以在创建命令别名时填充，也可以将其指定为位置参数(将在调用命令别名时进行填充)
# 以下示例展示了如何创建带有选项的命令别名:

# 使用选项 -f 和 -l 创建命令别名 'bfl' (用于 break-file-line)，其中选项已经是命令别名的一部分了
# 因此，如果用户想要按文件名和行号设置一个断点，但是又不想显式地使用 -f 和 -l 选项，则现在用户可以使用 'bfl' 来代替
# '%1' 和 '%2'是在使用命令别名时将传递的实际参数的位置占位符
# 位置占位符中的数字表示在使用命令别名时，实际值所占据的位置或顺序
# 命令别名中所有出现的 '%1' 将替换为第一个参数，命令别名中所有出现的 '%2' 将替换为第二个参数，以此类推
# 这也允许在命令别名中多次使用同一个实际参数(请参阅下面的 'process launch' 示例)
(lldb) command alias bfl breakpoint set -f %1 -l %2

# 注意:因为位置参数必须在命令别名中替换整个单词，所以目前还不能以如下方式拼接文件扩展名 ".cpp"
(lldb) command alias bcppfl breakpoint set -f %1.cpp -l %2

# 对于特别复杂的命令别名，请使用 "command regex" 命令替代
# 在上面的 'bfl' 例子中，实际的文件名将用 'bfl' 后面的第一个参数填充，实际的行号将用 'bfl' 后面的第二个参数填充
# 用户可以使用以下的命令别名
(lldb) command alias bfl breakpoint set -f %1 -l %2
(lldb) bfl my-file.c 137
# 这就像用户输入了
(lldb) breakpoint set -f my-file.c -l 137

# 另一个例子:
(lldb) command alias pltty process launch -s -o %1 -e %1
(lldb) pltty /dev/tty0
# 这就像用户输入了
(lldb) process launch -s -o /dev/tty0 -e /dev/tty0

# 如果用户总是希望将相同的值传递给特定的选项，则可以在命令别名中直接使用该值作为一个常量来定义该命令别名，而不是使用位置占位符
# 总是在指定的文件的第 3 行设置一个断点
(lldb) command alias bl3 breakpoint set -f %1 -l 3

# 重要提示:
# 因为这个命令需要原始输入，所以如果你使用任何命令选项，则你必须在命令选项的末尾和原始输入的开始之间使用 ' -- ' 分隔
```

## command delete

```bash
(lldb) help command delete
     # 删除一个或多个由 'command regex' 定义的自定义命令

Syntax: command delete <cmd-name>
```

## command history

```bash
(lldb) help command history
     # 转储此会话中的命令历史记录
	 # 历史列表中的命令可以使用 "!<INDEX>" 再次运行
	 # "!-<OFFSET>" 将重新运行历史列表末尾偏移 <OFFSET> 处的命令(计算当前命令)

Syntax: command history <cmd-options>

Command Options Usage:
  command history [-c <unsigned-integer>] [-e <unsigned-integer>] [-s <unsigned-integer>]
  command history [-C]

       -C ( --clear )
            # 清除当前命令历史

       -c <unsigned-integer> ( --count <unsigned-integer> )
            # 要打印多少条历史命令

       -e <unsigned-integer> ( --end-index <unsigned-integer> )
            # 要停止打印的历史命令的索引

       -s <unsigned-integer> ( --start-index <unsigned-integer> )
       		# 要开始打印的历史命令的索引
```

## command [regex](https://so.csdn.net/so/search?q=regex&spm=1001.2101.3001.7020)

```bash
(lldb) help command regex
      # 通过匹配正则表达式根据现有的命令定义一个自定义命令

Syntax: command regex <cmd-name> [s/<regex>/<subst>/ ...]

Command Options Usage:
  command regex [-h <none>] [-s <none>]

       -h <none> ( --help <none> )
            # 此命令别名的帮助文档

       -s <none> ( --syntax <none> )
            # 显示(典型的使用语法)的语法字符串

# 此命令允许用户创建强大的带有替换的正则表达式命令
# 正则表达式(regular expression)和替换(substitution)，使用以下正则表达式替换格式指定:
#    s/<regex>/<subst>/
# <regex> 是一个正则表达式，它可以使用括号来捕获正则表达式输入，并使用 %1 替换输出中捕获的第一个匹配，使用 %2 替换输出中捕获的第二个匹配，以此类推
# 如果提供了多个参数，则可以在命令行上指定所有正则表达式
# 如果在命令行上仅提供命令名称，则可以在单独的行中输入正则表达式(regular expression)和替换(substitution)，然后跟一个空行以终止命令定义

# 以下示例将定义一个名为 'f' 的正则表达式命令
# 如果 'f' 后面没有参数，则它将调用 'finish'
# 如果 'f' 后面有数字，则它将调用 'frame select <frame-idx>'
(lldb) command regex f s/^$/finish/ 's/([0-9]+)/frame select %1/'
```

## command script

```bash
(lldb) help command script
     # 用于管理由解释器脚本实现的自定义命令的命令

Syntax: command script <subcommand> [<subcommand-options>]

The following subcommands are supported:

      add       # 添加脚本函数作为 LLDB 命令
      clear  	# 删除所有脚本命令
      delete    # 删除一个脚本命令
      import    # 在 LLDB 中导入脚本模块
      list      # 列出定义的脚本命令

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

### command script add

```bash
(lldb) help command script add
     # 添加脚本函数作为 LLDB 命令

Syntax: command script add <cmd-options> <cmd-name>

Command Options Usage:
  command script add [-f <python-function>] [-h <help-text>] [-s <script-cmd-synchronicity>] <cmd-name>
  command script add [-c <python-class>] [-s <script-cmd-synchronicity>] <cmd-name>

       -c <python-class> ( --class <python-class> )
            # 要绑定到此命令名称的 Python 类的名称

       -f <python-function> ( --function <python-function> )
            # 要绑定到此命令名称的 Python 函数的名称

       -h <help-text> ( --help <help-text> )
            # 此命令的帮助文档

       -s <script-cmd-synchronicity> ( --synchronicity <script-cmd-synchronicity> )
       		# 设置此命令的执行与 LLDB 事件系统的同步性
       		# 可用值: synchronous | asynchronous | current

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

### command script clear

```bash
(lldb) help command script clear
     # 删除所有脚本命令

Syntax: command script clear
```

### command script delete

```bash
(lldb) help command script delete
     # 删除一个脚本命令

Syntax: command script delete <cmd-name>
```

### command script import

```bash
(lldb) help command script import
     # 在 LLDB 中导入脚本模块

Syntax: command script import <cmd-options> <filename> [<filename> [...]]

Command Options Usage:
  command script import [-r] <filename> [<filename> [...]]

       -r ( --allow-reload )
       		# 允许加载脚本，即使此脚本之前已经加载过
            # 此参数的存在是为了向后兼容
            # 始终允许重新加载，无论是否指定

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

### command script list

```bash
(lldb) help command script list
     # 列出定义的脚本命令

Syntax: command script list
```

## command source

```bash
(lldb) help command source
     # 从文件 <filename> 读取和执行 LLDB 命令

Syntax: command source <cmd-options> <filename>

Command Options Usage:
  command source [-s <boolean>] [-c <boolean>] [-e <boolean>] <filename>

       -c <boolean> ( --stop-on-continue <boolean> )
             # 如果为 true，则在继续时停止执行命令

       -e <boolean> ( --stop-on-error <boolean> )
             # 如果为 true，则在错误时停止执行命令

       -s <boolean> ( --silent-run <boolean> )
            # 如果为 true，则在执行时不回显命令

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

## command unalias

```bash
(lldb) help command unalias
     # 删除一个或多个由 'command alias' 定义的自定义命令

Syntax: command unalias <alias-name>
```

# disassemble

```bash
(lldb) help disassemble
     # 反汇编当前 target 中的指定指令
     # 默认为当前线程的当前栈帧中的当前函数

Syntax: disassemble [<cmd-options>]

Command Options Usage:
  disassemble [-bmr] -s <address-expression> [-A <arch>] [-C <num-lines>] [-e <address-expression>] [-F <disassembly-flavor>] [-P <plugin>]
  disassemble [-bmr] -s <address-expression> [-A <arch>] [-C <num-lines>] [-c <num-lines>] [-F <disassembly-flavor>] [-P <plugin>]
  disassemble [-bmr] [-A <arch>] [-C <num-lines>] [-c <num-lines>] [-F <disassembly-flavor>] [-n <function-name>] [-P <plugin>]
  disassemble [-bfmr] [-A <arch>] [-C <num-lines>] [-c <num-lines>] [-F <disassembly-flavor>] [-P <plugin>]
  disassemble [-bmpr] [-A <arch>] [-C <num-lines>] [-c <num-lines>] [-F <disassembly-flavor>] [-P <plugin>]
  disassemble [-blmr] [-A <arch>] [-C <num-lines>] [-F <disassembly-flavor>] [-P <plugin>]
  disassemble [-bmr] [-a <address-expression>] [-A <arch>] [-C <num-lines>] [-F <disassembly-flavor>] [-P <plugin>]

       -A <arch> ( --arch <arch> )
            # 指定要从交叉反汇编中使用的体系结构

       -C <num-lines> ( --context <num-lines> )
            # 要显示的源代码的上下文的行数

       -F <disassembly-flavor> ( --flavor <disassembly-flavor> )
            # 要使用的反汇编风格的名称
            # 目前唯一有效的选项是 default，用于 Intel 架构，att 和 intel

       -P <plugin> ( --plugin <plugin> )
            # 要使用的反汇编插件的名称

       -a <address-expression> ( --address <address-expression> )
            # 反汇编包含此地址的函数

       -b ( --bytes )
            # 反汇编时显示操作码字节(opcode bytes)

       -c <num-lines> ( --count <num-lines> )
            # 要显示的汇编指令的数量

       -e <address-expression> ( --end-address <address-expression> )
            # 要结束反汇编的地址

       -f ( --frame )
       		# 从当前帧的函数开始反汇编

       -l ( --line )
            # 如果有调试行表信息(debug line table information)，则反汇编当前帧的当前源代码行的指令，否则根据当前 PC 寄存器反汇编

       -m ( --mixed )
       		# 启用混合源(mixed source)和程序集(assembly)的显示
       		# hcg 注: 即输出源代码和汇编代码

       -n <function-name> ( --name <function-name> )
       		# 反汇编给定函数名的全部内容

       -p ( --pc )
       		# 根据当前 PC 寄存器反汇编

       -r ( --raw )
            # 打印没有符号信息的原始反汇编

       -s <address-expression> ( --start-address <address-expression> )
            # 要开始反汇编的地址
```

# expression

```bash
(lldb) help expression
     # 用于在当前线程上执行给定的表达式，并以 LLDB 的默认格式显示返回值
     # 期望使用原始输入(请参阅 'help raw-input')

Syntax: expression <cmd-options> -- <expr>

Command Options Usage:
  expression [-AFLORTgp] [-f <format>] [-G <gdb-format>] [-a <boolean>] [-j <boolean>] [-X <source-language>] [-v[<description-verbosity>]] [-i <boolean>] [-l <source-language>] [-t <unsigned-integer>] [-u <boolean>] [-d <none>] [-S <boolean>] [-D <count>] [-P <count>] [-Y[<count>]] [-V <boolean>] [-Z <count>] -- <expr>
  expression [-AFLORTgp] [-a <boolean>] [-j <boolean>] [-X <source-language>] [-i <boolean>] [-l <source-language>] [-t <unsigned-integer>] [-u <boolean>] [-d <none>] [-S <boolean>] [-D <count>] [-P <count>] [-Y[<count>]] [-V <boolean>] [-Z <count>] -- <expr>
  expression [-r] -- <expr>
  expression <expr>

       -A ( --show-all-children )
            # 显示所有子项
            # 忽略要显示的子项数量的上限

       -D <count> ( --depth <count> )
            # 转储聚合类型时设置最大递归深度(默认为无穷大)

       -F ( --flat )
            # 为每个变量或成员使用表达式路径的扁平格式显示结果

       -G <gdb-format> ( --gdb-format <gdb-format> )
            # 使用(GDB 格式说明符字符串)指定格式

       -L ( --location )
            # 显示变量的位置信息(内存地址或寄存器名称)

       -O ( --object-description )
            # 如果可能，使用特定于语言的描述 API 显示结果
            # 对于 Objective-C 来说，就是调用类对象或实例对象的 description 方法

       -P <count> ( --ptr-depth <count> )
            # 转储值时要遍历的指针数(默认为零)

       -R ( --raw-output )
            # 不要使用格式选项(即，使用原始输出格式)

       -S <boolean> ( --synthetic-type <boolean> )
            # 显示符合其合成提供程序的对象(如果可用)

       -T ( --show-types )
            # 转储值时显示变量的类型

       -V <boolean> ( --validate <boolean> )
            # 显示类型验证器的结果

       -X <source-language> ( --apply-fixits <source-language> )
            # 如果为 true，则简单的修复提示将自动应用于表达式

       -Y[<count>] ( --no-summary-depth=[<count>] )
            # 设置省略摘要信息停止的深度(默认为 1)

       -Z <count> ( --element-count <count> )
            # 将表达式的结果视为其类型是包含 <count> 个元素的数组

       -a <boolean> ( --all-threads <boolean> )
            # 如果在一个线程上没有完成表达式的执行，我们是否应该运行所有线程

       -d <none> ( --dynamic-type <none> )
            # 如果可用，则将对象显示为其完整的动态类型，而不是其静态类型
            # 可用值: no-dynamic-values | run-target | no-run-target

       -f <format> ( --format <format> )
            # 指定用于显示的格式

       -g ( --debug )
            # 指定后，通过在第一条指令上设置断点并强制不忽略断点(-i0)，并且不对错误(-u0)进行展开，来调试 JIT 代码

       -i <boolean> ( --ignore-breakpoints <boolean> )
            # 执行表达式时忽略断点的命中
            # hcg 注: 如果执行表达式时要能命中断点，则该选项需要设置为 false

       -j <boolean> ( --allow-jit <boolean> )
            # 控制表达式是否可以在解释器不支持的情况下回退到 JIT (默认为 true)

       -l <source-language> ( --language <source-language> )
            # 指定解析表达式时要使用的语言
            # 如果没有设置，则使用 target.language 的设置

       -p ( --top-level )
            # 将表达式解释为一个完整的翻译单元，而不将其注入本地上下文
            # 允许声明不带 $ 前缀的持久性顶级实体

       -r ( --repl )
            # 进入 Swift REPL

       -t <unsigned-integer> ( --timeout <unsigned-integer> )
            # 执行表达式的超时时间(以微秒为单位)

       -u <boolean> ( --unwind-on-error <boolean> )
            # 如果表达式导致崩溃或引发信号(signal)，则清理程序状态
            # 注意，与 gdb 不同的是，命中断点是由另一个选项 (-i) 控制的

       -v[<description-verbosity>] ( --description-verbosity=[<description-verbosity>] )
            # 如果要求进行对象描述，则此表达式的输出应该有多详细
            # 可用值: compact | full

# 单行和多行表达式:
#	在命令行上提供的表达式必须是没有换行符的完整表达式
# 	要构造多行表达式，请在输入 expression 命令后回车，LLDB 将进入多行表达式编辑器
#	在空行上输入回车以结束多行表达式

# 超时:
#	如果表达式可以静态执行(无需运行代码)，那么它将静态执行
#	否则，默认情况下，表达式将在当前线程上执行，但超时时间很短: 当前为 0.25 秒
#	如果表达式没有在超时时间内返回，则表达式的执行将被中断，并在所有线程运行时恢复
#	可以使用 -a 选项禁用对所有线程的重试
#	可以使用 -t 选项来设置更短的超时时间

# 用户定义的变量:
#	为方便起见，用户可以定义自己的变量，或在后续表达式中使用
#	定义它们的方式与在 C 中定义变量的方式相同
#	如果用户定义的变量的第一个字符是 $，则该变量的值将在后面的表达式中可用，否则该变量的值将仅在当前表达式中可用

# 断点后继续执行:
# 	如果你使用了 "-i false" 选项，并且表达式的执行被断点中断，一旦你完成了你的检视，则
#	你可以使用 "thread return -x" 命令从堆栈中删除表达式执行的帧
#	或者如果你仍然对表达式的结果感兴趣，则你可以使用 "continue" 命令以让表达式完成执行，此时使用线程格式中的 "thread.completed-expression" 键可以使用表达式的结果

# 示例如下:
expr my_struct->a = my_array[3]
expr -f bin -- (index * 8) + 5
expr unsigned int $foo = 5
expr char c[] = \"foo\"; c[0]

# 重要提示:
# 因为这个命令需要原始输入，所以如果你使用任何命令选项，则你必须在命令选项的末尾和原始输入的开始之间使用 ' -- ' 分隔
```

# [frame](https://so.csdn.net/so/search?q=frame&spm=1001.2101.3001.7020)

```bash
(lldb) help frame
     # 用于选择和检视当前线程的栈帧的命令

Syntax: frame <subcommand> [<subcommand-options>]

The following subcommands are supported:

      info          # 列出有关当前线程中当前栈帧的信息
      recognizer    # 用于编辑和查看帧识别器的命令
      select        # 在当前线程中根据索引选择当前的栈帧(请参阅 'thread backtrace')
      variable      # 显示当前栈帧的变量
      				# 默认为作用域内的所有参数和局部变量
      				# 可以指定参数、局部变量、文件静态变量和文件全局变量的名称
      				# 可以指定聚合变量的子变量，例如: 'var->child.x'
      				# 'frame variable' 命令中的操作符 -> 和 [] 不会调用操作符重载，而是直接访问指定的元素
      				# 如果要触发操作符的重载，则请使用 'expression' 命令来打印变量
                    # 值得注意的是，除了重载操作符外，当打印局部变量时，'expr local_var' 命令和 'frame var local_var' 命令会产生相同的结果
                    # 然而，'frame variable' 命令更具效率，因为它使用调试信息和直接读取内存，而不是解析和执行一个表达式(这可能涉及 JITing 和在目标程序中运行代码)

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

## frame info

```bash
(lldb) help frame info
     # 列出有关当前线程中当前栈帧的信息

Syntax: frame info
```

## frame recognizer

```bash
(lldb) help frame recognizer
     # 用于编辑和查看帧识别器的命令

Syntax: frame recognizer [<sub-command-options>]

The following subcommands are supported:

      add       # 添加一个新的帧识别器
      clear     # 删除所有帧识别器
      delete    # 删除一个帧识别器
      info      # 显示对指定的栈帧所应用的帧识别器(如果有的话)
      list      # 显示活动的帧识别器的列表

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

### frame recognizer add

```bash
(lldb) help frame recognizer add
     # 添加一个新的帧识别器

Syntax: frame recognizer add <cmd-options>

Command Options Usage:
  frame recognizer add [-x] [-n <name>] [-s <shlib-name>]
  frame recognizer add [-x] [-n <name>] [-l <python-class>] [-s <shlib-name>]

       -l <python-class> ( --python-class <python-class> )
            # 指定要用于此帧识别器的 Python 类的名称

       -n <name> ( --function <name> )
            # 此帧识别器要应用的函数的名称
            # 可以指定多次，除非提供了 -x|--regex

       -s <shlib-name> ( --shlib <shlib-name> )
            # 此帧识别器要应用的模块或共享库的名称

       -x ( --regex )
            # 函数名和模块名实际上是正则表达式

# 帧识别器允许基于 ABI、参数、该帧的其他特殊属性，检索有关特定帧的信息，即使没有源代码或调试信息
# 目前，一种用例是提取无法访问的函数参数，或扩充现有参数

# 通过实现 Python 类并使用 'frame recognizer add' 命令，可以添加自定义帧识别器
# 该 Python 类应该有一个 'get_recognized_arguments' 方法，它将接收一个 lldb.SBFrame 类型的参数，该参数用于表示我们试图识别的当前帧
# 该方法应该返回一个代表已识别参数的 lldb.SBValue 对象列表(该 lldb.SBValue 对象列表可以为空)

# 一个帧识别器的例子是，从 libc 的函数 'read'、'write'、'close' 中检索文件描述符的值:

class LibcFdRecognizer(object):
  def get_recognized_arguments(self, frame):
    if frame.name in ["read", "write", "close"]:
      fd = frame.EvaluateExpression("$arg1").unsigned
      value = lldb.target.CreateValueFromExpression("fd", "(int)%d" % fd)
      return [value]
    return []

# 可以通过 'command script import' 命令导入包含此实现的文件，然后使用 'frame recognizer add' 命令注册此帧识别器
# 将此帧识别器限制为 libc 库(在 macOS 上为 libsystem_kernel.dylib)很重要，以避免在其他模块中匹配具有相同名称的函数:

(lldb) command script import .../fd_recognizer.py
(lldb) frame recognizer add -l fd_recognizer.LibcFdRecognizer -n read -s libsystem_kernel.dylib

# 当程序在 libc 中的 'read' 函数的开始处暂停时，我们可以在 'frame variable' 命令中查看帧识别器的参数:

(lldb) b read
(lldb) r
Process 1234 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.3 frame #0: 0x00007fff06013ca0 libsystem_kernel.dylib`read
(lldb) frame variable
(int) fd = 3
```

### frame recognizer clear

```bash
(lldb) help frame recognizer clear
     # 删除所有帧识别器

Syntax: frame recognizer clear
```

### frame recognizer delete

```bash
(lldb) help frame recognizer delete
     # 删除一个帧识别器

Syntax: frame recognizer delete
```

### frame recognizer info

```bash
(lldb) help frame recognizer info
     # 显示对指定的栈帧所应用的帧识别器(如果有的话)

Syntax: frame recognizer info <frame-index>
```

### frame recognizer list

```bash
(lldb) help frame recognizer list
     # 显示活动的帧识别器的列表

Syntax: frame recognizer list
```

## frame select

```bash
(lldb) help frame select
     # 在当前线程中根据索引选择当前的栈帧(请参阅 'thread backtrace')

Syntax: frame select <cmd-options> [<frame-index>]

Command Options Usage:
  frame select [-r <offset>] [<frame-index>]

       -r <offset> ( --relative <offset> )
            # 相对于当前栈帧索引的偏移量

# hcg 注:
# 以下两条命令是等价的:
(lldb) up 
(lldb) frame select --relative=1
# 以下两条命令是等价的:
(lldb) down 
(lldb) frame select --relative=-1 

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

## frame variable

```bash
(lldb) help frame variable
     # 显示当前栈帧的变量
     # 默认为作用域内的所有参数和局部变量
     # 可以指定参数、局部变量、文件静态变量和文件全局变量的名称
     # 可以指定聚合变量的子变量，例如: 'var->child.x'
     # 'frame variable' 命令中的操作符 -> 和 [] 不会调用操作符重载，而是直接访问指定的元素
     # 如果要触发操作符的重载，则请使用 'expression' 命令来打印变量
     # 值得注意的是，除了重载操作符外，当打印局部变量时，'expr local_var' 命令和 'frame var local_var' 命令会产生相同的结果
     # 然而，'frame variable' 命令更具效率，因为它使用调试信息和直接读取内存，而不是解析和执行一个表达式(这可能涉及 JITing 和在目标程序中运行代码)

Syntax: frame variable <cmd-options> [<variable-name> [<variable-name> [...]]]

Command Options Usage:
  frame variable [-AFLORTacglrst] [-y <name>] [-z <name>] [-f <format>] [-G <gdb-format>] [-d <none>] [-S <boolean>] [-D <count>] [-P <count>] [-Y[<count>]] [-V <boolean>] [-Z <count>] [<variable-name> [<variable-name> [...]]]

       -A ( --show-all-children )
            # 显示所有子项
            # 忽略要显示的子项数量的上限

       -D <count> ( --depth <count> )
            # 转储聚合类型时设置最大递归深度(默认为无穷大)

       -F ( --flat )
            # 为每个变量或成员使用表达式路径的扁平格式显示结果

       -G <gdb-format> ( --gdb-format <gdb-format> )
            # 使用(GDB 格式说明符字符串)指定格式

       -L ( --location )
            # 显示变量的位置信息(内存地址或寄存器名称)

       -O ( --object-description )
            # 如果可能，使用特定于语言的描述 API 显示结果
            # 对于 Objective-C 来说，就是调用类对象或实例对象的 description 方法

       -P <count> ( --ptr-depth <count> )
            # 转储值时要遍历的指针数(默认为零)

       -R ( --raw-output )
            # 不要使用格式选项(即，使用原始输出格式)

       -S <boolean> ( --synthetic-type <boolean> )
            # 显示符合其合成提供程序的对象(如果可用)

       -T ( --show-types )
            # 转储值时显示变量的类型

       -V <boolean> ( --validate <boolean> )
            # 显示类型验证器的结果

       -Y[<count>] ( --no-summary-depth=[<count>] )
            # 设置省略摘要信息停止的深度(默认为 1)

       -Z <count> ( --element-count <count> )
            # 将表达式的结果视为其类型是包含 <count> 个元素的数组

       -a ( --no-args )
            # 省略函数参数

       -c ( --show-declaration )
            # 显示变量的声明信息(声明变量的源文件和行)

       -d <none> ( --dynamic-type <none> )
       		# 如果可用，则将对象显示为其完整的动态类型，而不是其静态类型
            # 可用值: no-dynamic-values | run-target | no-run-target

       -f <format> ( --format <format> )
            # 指定用于显示的格式

       -g ( --show-globals )
            # 显示当前栈帧的源文件的全局变量和静态变量

       -l ( --no-locals )
            # 省略局部变量

       -r ( --regex )
            # 名称查找的参数 <variable-name> 是正则表达式

       -s ( --scope )
            # 显示变量的作用域: argument(参数)、local(局部变量)、global(全局变量)、static(静态变量)

       -t ( --no-recognized-args )
            # 省略可识别的函数的参数

       -y <name> ( --summary <name> )
            # 指定变量输出应使用的摘要

       -z <name> ( --summary-string <name> )
            # 指定用于格式化变量输出的摘要字符串

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

# gdb-remote

```bash
(lldb) help gdb-remote
	 # 用于通过远程 GDB server 连接到一个进程
	 # 如果没有指定 host，则假设为 localhost
     # 期望使用原始输入(请参阅 'help raw-input')

Syntax: gdb-remote [<hostname>:]<portnum>
```

# gui

```bash
(lldb) help gui
     # 用于切换到基于 curses 的 GUI 模式

Syntax: gui
```

# help

```bash
(lldb) help help
     # 显示所有调试器命令的列表，或提供有关特定命令的详细信息

Syntax: help [<cmd-name>]

Command Options Usage:
  help [-ahu] [<cmd-name> [<cmd-name> [...]]]

       -a ( --hide-aliases )
            # 在命令列表中隐藏命令别名

       -h ( --show-hidden-commands )
            # 显示所有命令(包括前面带有下划线的命令)

       -u ( --hide-user-commands )
            # 在命令列表中隐藏用户自定义的命令

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

# kdp-remote

```bash
(lldb) help kdp-remote
     # 用于通过远程 KDP server 连接到一个进程
     # 如果没有指定 UDP 的端口，则假设为该端口为 41139
     # 期望使用原始输入(请参阅 'help raw-input')

Syntax: kdp-remote <hostname>[:<portnum>]
```

# language

```bash
(lldb) help language
     # 用于指定要在运行时操作的语言(C++、OC、RenderScript、Swift)

Syntax: language <language-name> <subcommand> [<subcommand-options>]

The following subcommands are supported:

      cplusplus       # 用于在 C++ 语言运行时上操作的命令
      objc            # 用于在 Objective-C 语言运行时上操作的命令
      renderscript    # 用于在 RenderScript 运行时上操作的命令
      swift           # 用于在 Swift 语言运行时上操作的命令

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

## language cplusplus

```bash
(lldb) help language cplusplus
     # 用于在 C++ 语言运行时上操作的命令

Syntax: cplusplus <subcommand> [<subcommand-options>]

The following subcommands are supported:

      demangle    # demangle 一个 C++ mangled name

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

### language cplusplus demangle

```bash
(lldb) help language cplusplus demangle
     # demangle 一个 C++ mangled name

Syntax: language cplusplus demangle
```

## language objc

```bash
(lldb) help language objc
     # 用于在 Objective-C 语言运行时上操作的命令

Syntax: objc <subcommand> [<subcommand-options>]

The following subcommands are supported:

      class-table       # 用于操作 Objective-C class table 的命令
      tagged-pointer    # 用于操作 Objective-C tagged pointer 的命令

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

### language objc class-table

```bash
(lldb) help language objc class-table
     # 用于操作 Objective-C class table 的命令

Syntax: class-table <subcommand> [<subcommand-options>]

The following subcommands are supported:

      dump    # 转储有关当前进程中已知的 Objective-C 类的信息

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

```bash
(lldb) help language objc class-table dump
     # 转储有关当前进程中已知的 Objective-C 类的信息

Syntax: language objc class-table dump

Command Options Usage:
  dump [-v] [<regular-expression>]

       -v ( --verbose )
            # 打印 ivar 和 method 的详细信息

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

### language objc tagged-pointer

```bash
(lldb) help language objc tagged-pointer
     # 用于操作 Objective-C tagged pointer 的命令

Syntax: class-table <subcommand> [<subcommand-options>]

The following subcommands are supported:

      info    # 转储有关 tagged pointer 的信息

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

```bash
(lldb) help language objc tagged-pointer info
     # 转储有关 tagged pointer 的信息

Syntax: language objc tagged-pointer info
```

## language renderscript

```bash
(lldb) help language renderscript
     # 用于在 RenderScript 运行时上操作的命令

Syntax: renderscript <subcommand> [<subcommand-options>]

The following subcommands are supported:

      allocation     # 处理 RenderScript 的 allocation 的命令
      context        # 处理 RenderScript 的 context 的命令
      kernel         # 处理 RenderScript 的 kernel 的命令
      module         # 处理 RenderScript 的 module 的命令
      reduction      # 处理 RenderScript 的 general reduction kernel 的命令
      scriptgroup    # 用于与 ScriptGroup 交互的命令
      status         # 显示当前的 RenderScript 运行时状态

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

### language renderscript allocation

```bash
(lldb) help language renderscript allocation
     # 处理 RenderScript 的 allocation 的命令

Syntax: renderscript allocation

The following subcommands are supported:

      dump       # 显示特定的 allocation 的内容
      list    	 # 列出 RenderScript 的 allocation 及其信息
      load    	 # 从文件中加载 RenderScript allocation 的内容
      refresh 	 # 重新计算所有 allocation 的细节
      save       # 将 RenderScript allocation 的内容写入到文件中

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

### language renderscript context

```bash
(lldb) help language renderscript context
     # 处理 RenderScript 的 context 的命令

Syntax: renderscript context

The following subcommands are supported:

      dump    # 转储 RenderScript 的上下文信息

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

### language renderscript kernel

```bash
(lldb) help language renderscript kernel
     # 处理 RenderScript 的 kernel 的命令

Syntax: renderscript kernel

The following subcommands are supported:

      breakpoint    # 在 RenderScript 的内核上生成断点的命令
      coordinate    # 显示当前内核调用的 (x,y,z) 坐标
      list          # 列出 RenderScript 内核名称和关联的脚本资源

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

### language renderscript module

```bash
(lldb) help language renderscript module
     # 处理 RenderScript 的 module 的命令

Syntax: renderscript module

The following subcommands are supported:

      dump    # 转储所有模块的 RenderScript 的特定信息

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

### language renderscript reduction

```bash
(lldb) help language renderscript reduction
     # 处理 RenderScript 的 general reduction kernel 的命令

Syntax: renderscript reduction

The following subcommands are supported:

      breakpoint    # 在渲染脚本的 general reduction kernel 上操作断点的命令

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

### language renderscript scriptgroup

```bash
(lldb) help language renderscript scriptgroup
     # 用于与 ScriptGroup 交互的命令

Syntax: renderscript scriptgroup

The following subcommands are supported:

      breakpoint    # 渲染脚本 ScriptGroup 断点交互
      list          # 列出所有当前发现的 ScriptGroup 

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

### language renderscript status

```bash
(lldb) help language renderscript scriptgroup
     # 显示当前的 RenderScript 运行时状态

Syntax: renderscript scriptgroup

The following subcommands are supported:

      breakpoint    # RenderScript ScriptGroup 断点交互
      list          # 列出当前发现的所有 ScriptGroup 

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

## language swift

```bash
(lldb) help language swift
     # 用于在 Swift 语言运行时上操作的命令

Syntax: swift <subcommand> [<subcommand-options>]

The following subcommands are supported:

      demangle    # demangle 一个 Swift mangled name
      refcount    # 检视 Swift 对象的引用计数
      			  # 期望使用原始输入(请参阅 'help raw-input')

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

### language swift demangle

```bash
(lldb) help language swift demangle
     # demangle 一个 Swift mangled name

Syntax: language swift demangle

Command Options Usage:
  demangle [-e]

       -e ( --expand )
            # LLDB 是否应该打印 demangled tree
```

### language swift refcount

```bash
(lldb) help language swift refcount
     # 检视 Swift 对象的引用计数
     # 期望使用原始输入(请参阅 'help raw-input')

Syntax: language swift refcount
```

# log

```bash
(lldb) help log
     # 用于控制 LLDB 内部日志记录的命令

Syntax: log <subcommand> [<command-options>]

The following subcommands are supported:

      disable    # 禁用一个或多个日志通道类别
      enable     # 启用单个日志通道的日志记录
      list       # 列出一个或多个日志通道的日志类别
      			 # 如果没有指定列出哪个日志通道，则列出所有日志通道
      timers     # 启用、禁用、转储、重置 LLDB 内部性能计时器

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

## log disable

```bash
(lldb) help log disable
     # 禁用一个或多个日志通道类别

Syntax: log disable <log-channel> <log-category> [<log-category> [...]]
```

## log enable

```bash
(lldb) help log enable
     # 启用单个日志通道的日志记录

Syntax: log enable <cmd-options> <log-channel> <log-category> [<log-category> [...]]

Command Options Usage:
  log enable [-FSTanpstv] [-f <filename>] <log-channel> <log-category> [<log-category> [...]]

       -F ( --file-function )
            # 拼接(生成日志的文件和函数的名称)

       -S ( --stack )
            # 在每个日志行之后拼接堆栈回溯

       -T ( --timestamp )
            # 在每个日志行之前拼接时间戳

       -a ( --append )
            # 拼接到日志文件中，而不是覆盖日志文件

       -f <filename> ( --file <filename> )
            # 设置日志要输出到的目标文件(即，设置要保存日志的文件)

       -n ( --thread-name )
            # 在每个日志行之前拼接生成该日志行的线程的名称

       -p ( --pid-tid )
            # 在每个日志行之前拼接生成该日志行的(进程的 ID 和线程的 ID)

       -s ( --sequence )
            # 在每个日志行之前拼接递增的整数序列 ID

       -t ( --threadsafe )
            # 启用线程安全的日志记录，以避免相互交错的日志行

       -v ( --verbose )
            # 启用详细的日志记录

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

## log list

```bash
(lldb) help log list
     # 列出一个或多个日志通道的日志类别
     # 如果没有指定列出哪个日志通道，则列出所有日志通道

Syntax: log list [<log-channel> [<log-channel> [...]]]
```

## log timers

```bash
(lldb) help log timers
     # 启用、禁用、转储、重置 LLDB 内部性能计时器

Syntax: log timers < enable <depth> | disable | dump | increment <bool> | reset >
```

# memory

```bash
(lldb) help memory
     # 用于操作当前目标进程中的内存的命令

Syntax: memory <subcommand> [<subcommand-options>]

The following subcommands are supported:

      find       # 在当前目标进程的内存中查找指定的值
      history    # 打印与地址关联的分配(allocation)/释放(deallocation)事件的(已记录的)堆栈跟踪
      read       # 从当前目标进程的内存中读取
      region     # 获取当前目标进程中包含特定地址的内存区域的信息
      write      # 写入到当前目标进程的内存中

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

## memory find

```bash
(lldb) help memory find
     # 在当前目标进程的内存中查找指定的值

Syntax: memory find <cmd-options> <address-expression> <address-expression>

Command Options Usage:
  memory find -e <expr> [-c <count>] [-o <offset>] <address-expression> <address-expression>
  memory find -s <name> [-c <count>] [-o <offset>] <address-expression> <address-expression>

       -c <count> ( --count <count> )
            # 执行搜索的次数

       -e <expr> ( --expression <expr> )
            # 计算表达式以获取匹配的字节

       -o <offset> ( --dump-offset <offset> )
            # 当为匹配项转储内存时，从匹配位置的指定偏移量处开始进行转储

       -s <name> ( --string <name> )
            # 使用文本查找匹配的字节

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

## memory history

```bash
(lldb) help memory history
     # 打印与地址关联的分配(allocation)/释放(deallocation)事件的(已记录的)堆栈跟踪

Syntax: memory history <address>
```

## memory read

```bash
(lldb) help memory read
     # 从当前目标进程的内存中读取

Syntax: memory read <cmd-options> <address-expression> [<address-expression>]

Command Options Usage:
  memory read [-r] [-f <format>] [-c <count>] [-G <gdb-format>] [-s <byte-size>] [-l <number-per-line>] [-o <filename>] <address-expression> [<address-expression>]
  memory read [-br] [-f <format>] [-c <count>] [-s <byte-size>] [-o <filename>] <address-expression> [<address-expression>]
  memory read [-AFLORTr] -t <name> [-f <format>] [-c <count>] [-G <gdb-format>] [-E <count>] [-o <filename>] [-d <none>] [-S <boolean>] [-D <count>] [-P <count>] [-Y[<count>]] [-V <boolean>] [-Z <count>] <address-expression> [<address-expression>]
  memory read -t <name> [-x <source-language>] <address-expression> [<address-expression>]

       -A ( --show-all-children )
            # 显示所有子项
            # 忽略要显示的子项数量的上限

       -D <count> ( --depth <count> )
            # 转储聚合类型时设置最大递归深度(默认为无穷大)

       -E <count> ( --offset <count> )
            # 在开始显示数据之前，要跳过多少个指定类型的元素

       -F ( --flat )
            # 为每个变量或成员使用表达式路径的扁平格式显示结果

       -G <gdb-format> ( --gdb-format <gdb-format> )
            # 使用(GDB 格式说明符字符串)指定格式

       -L ( --location )
            # 显示变量的位置信息(内存地址或寄存器名称)

       -O ( --object-description )
            # 如果可能，使用特定于语言的描述 API 显示结果
            # 对于 Objective-C 来说，就是调用类对象或实例对象的 description 方法

       -P <count> ( --ptr-depth <count> )
            # 转储值时要遍历的指针数(默认为零)

       -R ( --raw-output )
            # 不要使用格式选项(即，使用原始输出格式)

       -S <boolean> ( --synthetic-type <boolean> )
            # 显示符合其合成提供程序的对象(如果可用)

       -T ( --show-types )
            # 转储值时显示变量的类型

       -V <boolean> ( --validate <boolean> )
            # 显示类型验证器的结果

       -Y[<count>] ( --no-summary-depth=[<count>] )
            # 设置省略摘要信息停止的深度(默认为 1)

       -Z <count> ( --element-count <count> )
            # 将表达式的结果视为其类型是包含 <count> 个元素的数组

       -b ( --binary )
            # 如果为 true，则内存将保存为二进制
            # 如果为 false，则内存将保存为 ASCII 转储，使用每行设置: 格式(format)、大小(size)、计数(count)、数字(number)

       -c <count> ( --count <count> )
            # 要显示的总条目数

       -d <none> ( --dynamic-type <none> )
            # 如果可用，则将对象显示为其完整的动态类型，而不是其静态类型
            # 可用值: no-dynamic-values | run-target | no-run-target

       -f <format> ( --format <format> )
            # 指定用于显示的格式

       -l <number-per-line> ( --num-per-line <number-per-line> )
            # 每行要显示的条目的数量

       -o <filename> ( --outfile <filename> )
            # 指定捕获命令输出的路径

       -r ( --force )
            # 如果读取超过 target.max-memory-read-size 个字节，则需要指定该选项

       -s <byte-size> ( --size <byte-size> )
            # 以所选格式显示时，要使用的大小(以 Byte 为单位)

       -t <name> ( --type <name> )
            # 要查看内存的类型的名称

       -x <source-language> ( --language <source-language> )
            # 要查看内存的类型的语言

       --append-outfile
            # 拼接到用 '--outfile <path>' 指定的文件中

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

## memory region

```bash
(lldb) help memory region
     # 获取当前目标进程中包含特定地址的内存区域的信息

Syntax: memory region ADDR
```

## memory write

```bash
(lldb) help memory write
     # 写入到当前目标进程的内存中

Syntax: memory write <cmd-options> <address> <value> [<value> [...]]

Command Options Usage:
  memory write [-f <format>] [-s <byte-size>] <address> <value> [<value> [...]]
  memory write -i <filename> [-s <byte-size>] [-o <offset>] <address> <value> [<value> [...]]

       -f <format> ( --format <format> )
            # 指定用于显示的格式

       -i <filename> ( --infile <filename> )
            # 将指定文件的内容写入到内存中

       -o <offset> ( --offset <offset> )
            # 从输入文件中指定的偏移量处开始，写入字节

       -s <byte-size> ( --size <byte-size> )
            # 以所选格式显示时，要使用的大小(以 Byte 为单位)

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

# platform

```bash
(lldb) help platform
     # 用于管理和创建操作系统平台的命令

Syntax: platform [connect|disconnect|info|list|status|select] ...

The following subcommands are supported:

      connect           # 通过指定的 URL 连接到指定的系统平台(以作为当前系统平台)
      disconnect        # 断开与当前系统平台的连接
      file              # 用于访问当前系统平台上的文件的命令
      get-file          # 将文件从远程终端传输到本地主机
      get-size          # 从远程终端获取文件大小
      list              # 列出所有可用的系统平台
      mkdir             # 在远程终端创建一个新目录
      process           # 用于(查询、启动、附加到)当前系统平台上的进程的命令
      put-file          # 将文件从本地主机传输到远程终端
      select            # 选择指定的系统平台作为当前的系统平台
      					# 如果指定的系统平台未创建，则会创建指定的系统平台
      settings          # 对当前目标系统平台进行设置，或对指定名称的系统平台进行设置
      shell             # 在当前系统平台上运行 shell 命令
      					# 期望使用原始输入(请参阅 'help raw-input')
      status            # 显示当前系统平台的状态
      target-install    # 将指定的 target (bundle 或 executable file)安装到远程终端

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

## platform connect

```bash
(lldb) help platform connect
     # 通过指定的 URL 连接到指定的系统平台(以作为当前系统平台)

Syntax: platform connect <connect-url>

Command Options Usage:
  platform connect [-irs] [-R <cmd-name>] [-P <cmd-name>] [-S <cmd-name>] [-c <path>]

       -P <cmd-name> ( --rsync-prefix <cmd-name> )
            # 放置在远程路径之前的，特定于系统平台的 rsync 前缀

       -R <cmd-name> ( --rsync-opts <cmd-name> )
            # rsync 工作所需的特定于系统平台的选项

       -S <cmd-name> ( --ssh-opts <cmd-name> )
            # SSH 工作所需的特定于系统平台的选项

       -c <path> ( --local-cache-dir <path> )
            # 存储文件本地副本的路径

       -i ( --ignore-remote-hostname )
            # 编写 rsync 命令时不要自动填写远程主机名

       -r ( --rsync )
            # 启用 rsync

       -s ( --ssh )
            # 启用 SSH
```

## platform disconnect

```bash
(lldb) help platform disconnect
     # 断开与当前系统平台的连接

Syntax: platform disconnect
```

## platform file

```bash
(lldb) help platform file
     # 用于访问当前系统平台上的文件的命令

Syntax: platform file [open|close|read|write] ...

The following subcommands are supported:

      close    # 关闭远程终端的文件
      open     # 打开远程终端的文件
      read     # 从远程终端的文件中读取数据
      write    # 将数据写入远程终端的文件中

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

### platform file close

```bash
(lldb) help platform file close
     # 关闭远程终端的文件

Syntax: platform file close
```

### platform file open

```bash
(lldb) help platform file open
     # 打开远程终端的文件

Syntax: platform file open <cmd-options>

Command Options Usage:
  platform file open [-RWXdertwx] [-s <perms=string>] [-v <perms-numeric>]

       -R ( --group-read )
            # 允许读取: group

       -W ( --group-write )
            # 允许写入: group

       -X ( --group-exec )
            # 允许执行: group

       -d ( --world-read )
            # 允许读取: all

       -e ( --world-exec )
            # 允许执行: all

       -r ( --user-read )
            # 允许读取: user

       -s <perms=string> ( --permissions-string <perms=string> )
            # 使用字符串的形式给出权限(例如: rwxr-xr--)

       -t ( --world-write )
            # 允许写入: all

       -v <perms-numeric> ( --permissions-value <perms-numeric> )
            # 使用数字的形式给出权限(例如: 757)

       -w ( --user-write )
            # 允许写入: user

       -x ( --user-exec )
            # 允许执行: user
```

### platform file read

```bash
(lldb) help platform file read
     # 从远程终端的文件中读取数据

Syntax: platform file read <cmd-options>

Command Options Usage:
  platform file read [-c <count>] [-o <index>]

       -c <count> ( --count <count> )
            # 要从文件中读取的字节数

       -o <index> ( --offset <index> )
            # 从文件中指定的偏移处开始读取
```

### platform file write

```bash
(lldb) help platform file write
     # 将数据写入远程终端的文件中

Syntax: platform file write <cmd-options>

Command Options Usage:
  platform file write [-d <value>] [-o <index>]

       -d <value> ( --data <value> )
            # 要写入到文件中的文本

       -o <index> ( --offset <index> )
            # 从文件中指定的偏移处开始写入
```

## platform get-file

```bash
(lldb) help platform get-file
     # 将文件从远程终端传输到本地主机

Syntax: platform get-file <remote-file-spec> <local-file-spec>

# 示例如下:
# 将远程终端中的文件 /the/remote/file/path 传输到本地主机 /the/local/file/path 中
(lldb) platform get-file /the/remote/file/path /the/local/file/path
```

## platform get-size

```bash
(lldb) help platform get-size
     # 从远程终端获取文件大小

Syntax: platform get-size <remote-file-spec>

# 示例如下:
# 获取远程终端中的文件 /the/remote/file/path 的大小
(lldb) platform get-size /the/remote/file/path
```

## platform list

```bash
(lldb) help platform list
     # 列出所有可用的系统平台

Syntax: platform list
```

## platform mkdir

```bash
(lldb) help platform mkdir
     # 在远程终端创建一个新目录

Syntax: platform mkdir <cmd-options>

Command Options Usage:
  platform mkdir [-RWXdertwx] [-s <perms=string>] [-v <perms-numeric>]

       -R ( --group-read )
            # 允许读取: group

       -W ( --group-write )
             # 允许写入: group

       -X ( --group-exec )
            # 允许执行: group

       -d ( --world-read )
            # 允许读取: all

       -e ( --world-exec )
            # 允许执行: all

       -r ( --user-read )
            # 允许读取: user

       -s <perms=string> ( --permissions-string <perms=string> )
            # 使用字符串的形式给出权限(例如: rwxr-xr--)

       -t ( --world-write )
            # 允许写入: all

       -v <perms-numeric> ( --permissions-value <perms-numeric> )
            # 使用数字的形式给出权限(例如: 757)

       -w ( --user-write )
            # 允许写入: user

       -x ( --user-exec )
            # 允许执行: user
```

## platform process

```bash
(lldb) help platform process
     # 用于(查询、启动、附加到)当前系统平台上的进程的命令

Syntax: platform process [attach|launch|list] ...

The following subcommands are supported:

      attach    # 附加到指定的进程中
      info      # 通过进程 ID 获取一个或多个进程的详细信息
      launch    # 在远程系统平台上启动一个新进程
      list      # 在远程系统平台上列出与指定的(名称、进程 ID、其他属性)相匹配的进程

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

### platform process attach

```bash
(lldb) help platform process attach
     # 附加到指定的进程中

Syntax: platform process attach <cmd-options>

Command Options Usage:
  platform process attach [-p <pid>] [-P <plugin>]
  platform process attach [-w] [-n <process-name>] [-P <plugin>]

       -P <plugin> ( --plugin <plugin> )
            # 要使用的进程插件的名称

       -n <process-name> ( --name <process-name> )
            # 要附加到的进程的名称

       -p <pid> ( --pid <pid> )
            # 要附加到的进程的 ID(现有进程)

       -w ( --waitfor )
            # 等待带有 <process-name> 名称的进程启动
```

### platform process info

```bash
(lldb) help platform process info
     # 通过进程 ID 获取一个或多个进程的详细信息

Syntax: platform process info <pid> [<pid> <pid> ...]
```

### platform process launch

```bash
(lldb) help platform process launch
     # 在远程系统平台上启动一个新进程

Syntax: platform process launch program

Command Options Usage:
  platform process launch [-s] [-A <boolean>] [-p <plugin>] [-w <directory>] [-a <arch>] [-v <none>] [-c[<filename>]] [-i <filename>] [-o <filename>] [-e <filename>]
  platform process launch [-st] [-A <boolean>] [-p <plugin>] [-w <directory>] [-a <arch>] [-v <none>] [-c[<filename>]]
  platform process launch [-ns] [-A <boolean>] [-p <plugin>] [-w <directory>] [-a <arch>] [-v <none>] [-c[<filename>]]
  platform process launch [-s] [-A <boolean>] [-p <plugin>] [-w <directory>] [-a <arch>] [-v <none>] [-X <boolean>]

       -A <boolean> ( --disable-aslr <boolean> )
            # 设置是否在启动进程时禁用地址空间布局随机化(aslr, address space layout randomization)

       -X <boolean> ( --shell-expand-args <boolean> )
            # 设置是否在启动时对进程进行 shell 扩展参数

       -a <arch> ( --arch <arch> )
            # 设置进程的 CPU 体系结构以在不明确时启动

       -c[<filename>] ( --shell=[<filename>] )
            # 在 shell 中运行该进程(并非所有系统平台都支持)

       -e <filename> ( --stderr <filename> )
            # 将进程的 stderr 重定向到 <filename>

       -i <filename> ( --stdin <filename> )
            # 将进程的 stdin 重定向到 <filename>

       -n ( --no-stdio )
            # 不要设置 terminal I/O 去运行进程

       -o <filename> ( --stdout <filename> )
            # 将进程的 stdout 重定向到 <filename>

       -p <plugin> ( --plugin <plugin> )
            # 要使用的进程插件的名称

       -s ( --stop-at-entry )
            # 启动进程时暂停在程序的入口点

       -t ( --tty )
            # 在终端中启动进程(并非所有系统平台都支持)

       -v <none> ( --environment <none> )
            # 指定环境变量的 name/value 字符串(例如: --environment NAME=VALUE)
            # 可以多次重复此选项以指定多个环境变量的 name/value 字符串

       -w <directory> ( --working-dir <directory> )
            # 在运行下级目录时，将当前工作目录设置为 <path>
```

### platform process list

```bash
(lldb) help platform process list
     # 在远程系统平台上列出与指定的(名称、进程 ID、其他属性)相匹配的进程

Syntax: platform process list

Command Options Usage:
  platform process list [-Avx] [-p <pid>]
  platform process list [-Avx] -n <process-name> [-a <arch>] [-G <unsigned-integer>] [-U <unsigned-integer>] [-g <unsigned-integer>] [-P <pid>] [-u <unsigned-integer>]
  platform process list [-Avx] -e <process-name> [-a <arch>] [-G <unsigned-integer>] [-U <unsigned-integer>] [-g <unsigned-integer>] [-P <pid>] [-u <unsigned-integer>]
  platform process list [-Avx] -s <process-name> [-a <arch>] [-G <unsigned-integer>] [-U <unsigned-integer>] [-g <unsigned-integer>] [-P <pid>] [-u <unsigned-integer>]
  platform process list [-Avx] -c <process-name> [-a <arch>] [-G <unsigned-integer>] [-U <unsigned-integer>] [-g <unsigned-integer>] [-P <pid>] [-u <unsigned-integer>]
  platform process list [-Avx] -r <regular-expression> [-a <arch>] [-G <unsigned-integer>] [-U <unsigned-integer>] [-g <unsigned-integer>] [-P <pid>] [-u <unsigned-integer>]

       -A ( --show-args )
            # 显示进程的参数而不是进程的可执行文件基本名称

       -G <unsigned-integer> ( --egid <unsigned-integer> )
            # [POSIX] 查找具有匹配的有效 group ID 的进程

       -P <pid> ( --parent <pid> )
            # 查找具有匹配的父进程 ID 的进程

       -U <unsigned-integer> ( --euid <unsigned-integer> )
            # [POSIX] 查找具有匹配的有效 user ID 的进程

       -a <arch> ( --arch <arch> )
            # 查找具有匹配的 CPU 架构的进程

       -c <process-name> ( --contains <process-name> )
            # 查找可执行文件基本名称中包含有指定字符串的进程

       -e <process-name> ( --ends-with <process-name> )
            # 查找可执行文件基本名称以指定字符串结尾的进程

       -g <unsigned-integer> ( --gid <unsigned-integer> )
            # [POSIX] 查找具有匹配的 group ID 的进程

       -n <process-name> ( --name <process-name> )
            # 查找可执行文件基本名称与指定字符串相匹配的进程

       -p <pid> ( --pid <pid> )
            # 列出指定进程 ID 所标识的进程的信息

       -r <regular-expression> ( --regex <regular-expression> )
            # 查找可执行文件基本名称与指定正则表达式相匹配的进程

       -s <process-name> ( --starts-with <process-name> )
            # 查找可执行文件基本名称以指定字符串开头的进程

       -u <unsigned-integer> ( --uid <unsigned-integer> )
            # [POSIX] 查找具有匹配的 user ID 的进程

       -v ( --verbose )
            # 启用详细输出

       -x ( --all-users )
            # 显示匹配所有 user ID 的进程
```

## platform put-file

```bash
(lldb) help platform put-file
     # 将文件从本地主机传输到远程终端

Syntax: platform put-file
```

## platform select

```bash
(lldb) help platform select
     # 选择指定的系统平台作为当前的系统平台
     # 如果指定的系统平台未创建，则会创建指定的系统平台

Syntax: platform select <platform-name>

Command Options Usage:
  platform select [-v <none>] [-b <none>] [-S <filename>]

       -S <filename> ( --sysroot <filename> )
            # 指定包含所有远程系统文件根目录的 SDK 根目录

       -b <none> ( --build <none> )
            # 指定初始 SDK 内部版本号

       -v <none> ( --version <none> )
            # 在连接之前指定要使用的初始 SDK 版本
```

## platform settings

```bash
(lldb) help platform settings
     # 对当前目标系统平台进行设置，或对指定名称的系统平台进行设置

Syntax: platform settings

Command Options Usage:
  platform settings [-w <path>]

       -w <path> ( --working-dir <path> )
            # 系统平台的工作目录
```

## platform shell

```bash
(lldb) help platform shell
     # 在当前系统平台上运行 shell 命令
     # 期望使用原始输入(请参阅 'help raw-input')

Syntax: platform shell <shell-command>

Command Options Usage:
  platform shell [-h] [-t <value>]

       -h ( --host )
            # 启用后，在主机 shell 上运行命令

       -t <value> ( --timeout <value> )
            # 等待远程主机完成命令运行的秒数

# 重要提示:
# 因为这个命令需要原始输入，所以如果你使用任何命令选项，则你必须在命令选项的末尾和原始输入的开始之间使用 ' -- ' 分隔
```

## platform status

```bash
(lldb) help platform status
     # 显示当前系统平台的状态

Syntax: platform status
```

## platform target-install

```bash
(lldb) help platform target-install
     # 将指定的 target (bundle 或 executable file)安装到远程终端

Syntax: platform target-install <local-thing> <remote-sandbox>
```

# plugin

```bash
(lldb) help plugin
     # 用于管理 LLDB 插件的命令

Syntax: plugin <subcommand> [<subcommand-options>]

The following subcommands are supported:

      load               # 导入一个实现 LLDB 插件的 dylib
      structured-data    # 每个插件结构化数据命令的父级

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

## plugin load

```bash
(lldb) help plugin load
     # 导入一个实现 LLDB 插件的 dylib

Syntax: plugin load <filename>
```

## plugin structured-data

```bash
(lldb) help plugin structured-data
     # 每个插件结构化数据命令的父级

Syntax: plugin structured-data <plugin>

The following subcommands are supported:

      darwin-log    # 用于配置 Darwin os_log 支持的命令

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

### plugin structured-data darwin-log

```bash
(lldb) help plugin structured-data darwin-log
     # 用于配置 Darwin os_log 支持的命令

Syntax: plugin structured-data darwin-log

The following subcommands are supported:

      disable    # 禁用 Darwin 日志收集
      enable     # 启用 Darwin 日志收集，或使用修改后的配置重新启用 Darwin 日志收集
      status     # 显示是否有受支持的 Darwin 日志可用并已启用

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

#### plugin structured-data darwin-log disable

```bash
(lldb) help plugin structured-data darwin-log disable
     # 禁用 Darwin 日志收集

Syntax: plugin structured-data darwin-log disable
```

#### plugin structured-data darwin-log enable

```bash
(lldb) help plugin structured-data darwin-log enable
     # 启用 Darwin 日志收集，或使用修改后的配置重新启用 Darwin 日志收集

Syntax: plugin structured-data darwin-log enable

Command Options Usage:
  enable [-ACacdirs] [-f <raw-input>] [-l <boolean>] [-n <boolean>] [-e <boolean>] [-b <boolean>]

       -A ( --all-fields )
            # 指定应显示所有标题字段

       -C ( --activity-chain )
            # 在显示日志消息时，在消息头中包含活动父子链
            # 活动层级结构显示为
            # {grandparent-activity}:{parent-activity}:{activity}[:...]

       -a ( --any-process )
            # 指定应包括来自其他相关进程的日志消息

       -b <boolean> ( --broadcast-events <boolean> )
            # 指定插件是否应该广播事件
            # 广播日志事件是在 LLDB 命令行中显示日志条目的要求
            # 如果 LLDB 客户端想要处理日志事件，则它也是必需的
            # 默认值为 true

       -c ( --category )
            # 在显示日志消息时，在消息标题中包含类别

       -d ( --debug )
            # 指定应包括调试级别的日志消息
            # 指定 --debug 意味着 --info

       -e <boolean> ( --echo-to-stderr <boolean> )
            # 指定 os_log() 和 NSLog() 消息是否会回显到目标程序的 stderr
            # 当启用 DarwinLog 时，我们关闭了 os_log() 和 NSLog() 到程序的 stderr 的映射
            # 将此标志设置为 true 将恢复 stderr 映射，默认为 false

       -f <raw-input> ( --filter <raw-input> )
            # 将过滤规则附加到日志消息过滤链
            # 通过多次指定此选项可以添加多个过滤规则，每次添加一个过滤规则
            # 过滤规则按照指定的顺序进行处理，--no-match-accepts 用于设置与任何过滤规则都不匹配的消息
    		# 过滤规则格式如下:
            # --filter "{action} {attribute} {op}"
			# {action} := 
			#		accept | reject
			# {attribute} := 
			# 		activity       |  // message's most-derived activity
       		# 		activity-chain |  // message's {parent}:{child} activity
			# 		category       |  // message's category
       		# 		message        |  // message's expanded contents
       		# 		subsystem      |  // message's subsystem
	    	# {op} :=
			# 		match {exact-match-text} |
			# 		regex {search-regex}
			# 		使用的正则表达式风格是 C++ std::regex ECMAScript 格式
			# 		更喜欢像 [[: digit:]] 这样的字符类，因为要正确地转义反斜杠很容易出错

       -i ( --info )
            # 指定应包含信息级别的日志消息

       -l <boolean> ( --live-stream <boolean> )
            # 指定日志事件是实时流式传输还是缓冲捕获
            # True 表示实时流式传输，false 表示缓冲捕获
            # 默认值为 true (实时流式传输)
            # 实时流式传输将以更少的延迟传递日志消息，缓冲捕获的观察者效果较小

       -n <boolean> ( --no-match-accepts <boolean> )
            # 指定是接受还是拒绝，与任何过滤规则不匹配的日志消息，其中 true 表示接受
            # 默认值为 true

       -r ( --timestamp-relative )
            # 在打印日志消息时，在消息头中包含时间戳
            # 时间戳是相对于第一条显示的日志消息的

       -s ( --subsystem )
            # 在显示日志消息时，将子系统包含在消息头中
```

#### plugin structured-data darwin-log status

```bash
(lldb) help plugin structured-data darwin-log status
     # 显示是否有受支持的 Darwin 日志可用并已启用

Syntax: plugin structured-data darwin-log status
```

# process

```bash
(lldb) help process
     # 用于与当前平台上的进程进行交互的命令

Syntax: process <subcommand> [<subcommand-options>]

The following subcommands are supported:

      attach       # 附加到指定的进程
      connect      # 连接到指定的远程调试服务
      continue     # 继续执行当前进程中的所有线程
      detach       # 从当前目标进程中分离
      handle       # 管理当前目标进程中 LLDB 对 OS 信号的处理，默认显示当前策略
      interrupt    # 中断当前目标进程
      kill         # 终止当前目标进程
      launch       # 在调试器中启动可执行文件
      load         # 将指定的共享库加载到当前进程中
      plugin       # 向当前目标进程的插件发送自定义命令
      save-core    # 使用适当的文件类型将当前进程保存为核心文件(core file)
      signal       # 向当前目标进程发送一个 UNIX 信号
      status       # 显示当前目标进程的状态和暂停位置
      unload       # 使用之前调用 "process load" 命令所返回的索引，从当前进程中卸载指定的共享库

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

## process attach

```bash
(lldb) help process attach
     # 附加到指定的进程

Syntax: process attach <cmd-options>

Command Options Usage:
  process attach [-c] [-p <pid>] [-P <plugin>]
  process attach [-ciw] [-n <process-name>] [-P <plugin>]

       -P <plugin> ( --plugin <plugin> )
            # 要使用的进程插件的名称

       -c ( --continue )
            # 附加后立即继续该进程

       -i ( --include-existing )
            # 在执行 'attach -w' 命令时包括现有进程

       -n <process-name> ( --name <process-name> )
            # 要附加到的进程的名称

       -p <pid> ( --pid <pid> )
            # 要附加到的进程的 ID (现有进程)

       -w ( --waitfor )
            # 等待带有 <process-name> 名称的进程启动
```

## process connect

```bash
(lldb) help process connect
     # 连接到指定的远程调试服务

Syntax: process connect <remote-url>

Command Options Usage:
  process connect [-p <plugin>]

       -p <plugin> ( --plugin <plugin> )
            # 要使用的进程插件的名称
```

## process continue

```bash
(lldb) help process continue
     # 继续执行当前进程中的所有线程

Syntax: process continue

Command Options Usage:
  process continue [-i <unsigned-integer>]

       -i <unsigned-integer> ( --ignore-count <unsigned-integer> )
            # 忽略当前选定线程经过的 <N> 个断点(如果断点存在)
```

## process detach

```bash
(lldb) help process detach
     # 从当前目标进程中分离

Syntax: process detach

Command Options Usage:
  process detach [-s <boolean>]

       -s <boolean> ( --keep-stopped <boolean> )
            # 进程是否应该在分离时保持暂停(如果可能)
```

## process handle

```bash
(lldb) help process handle
     # 管理当前目标进程中 LLDB 对 OS 信号的处理，默认显示当前策略

Syntax: process handle <cmd-options> [<unix-signal> [<unix-signal> [...]]]

Command Options Usage:
  process handle [-n <boolean>] [-p <boolean>] [-s <boolean>] [<unix-signal> [<unix-signal> [...]]]

       -n <boolean> ( --notify <boolean> )
            # 如果收到 OS 信号，调试器是否应该通知用户

       -p <boolean> ( --pass <boolean> )
            # OS 信号是否应该传递给进程

       -s <boolean> ( --stop <boolean> )
            # 如果收到 OS 信号，进程是否应该暂停

# 如果未指定任何 OS 信号，则更新全部的 OS 信号
# 如果未指定更新选项，则列出当前的值

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

## process interrupt

```bash
(lldb) help process interrupt
     # 中断当前目标进程

Syntax: process interrupt
```

## process kill

```bash
(lldb) help process kill
     # 终止当前目标进程

Syntax: process kill
```

## process launch

```bash
(lldb) help process launch
     # 在调试器中启动可执行文件

Syntax: process launch <cmd-options> [<run-args>]

Command Options Usage:
  process launch [-s] [-A <boolean>] [-p <plugin>] [-w <directory>] [-a <arch>] [-v <none>] [-c[<filename>]] [-i <filename>] [-o <filename>] [-e <filename>] [<run-args>]
  process launch [-st] [-A <boolean>] [-p <plugin>] [-w <directory>] [-a <arch>] [-v <none>] [-c[<filename>]] [<run-args>]
  process launch [-ns] [-A <boolean>] [-p <plugin>] [-w <directory>] [-a <arch>] [-v <none>] [-c[<filename>]] [<run-args>]
  process launch [-s] [-A <boolean>] [-p <plugin>] [-w <directory>] [-a <arch>] [-v <none>] [-X <boolean>] [<run-args>]

       -A <boolean> ( --disable-aslr <boolean> )
            # 设置是否在启动进程时禁用地址空间布局随机化(aslr, address space layout randomization)

       -X <boolean> ( --shell-expand-args <boolean> )
            # 设置是否在启动时对进程进行 shell 扩展参数

       -a <arch> ( --arch <arch> )
            # 设置进程的 CPU 体系结构以在不明确时启动

       -c[<filename>] ( --shell=[<filename>] )
            # 在 shell 中运行该进程(并非所有系统平台都支持)

       -e <filename> ( --stderr <filename> )
            # 将进程的 stderr 重定向到 <filename>

       -i <filename> ( --stdin <filename> )
            # 将进程的 stdin 重定向到 <filename>

       -n ( --no-stdio )
            # 不要设置 terminal I/O 去运行进程

       -o <filename> ( --stdout <filename> )
            # 将进程的 stdout 重定向到 <filename>

       -p <plugin> ( --plugin <plugin> )
            # 要使用的进程插件的名称

       -s ( --stop-at-entry )
            # 启动进程时暂停在程序的入口点

       -t ( --tty )
            # 在终端中启动进程(并非所有系统平台都支持)

       -v <none> ( --environment <none> )
            # 指定环境变量的 name/value 字符串(例如: --environment NAME=VALUE)
            # 可以多次重复此选项以指定多个环境变量的 name/value 字符串

       -w <directory> ( --working-dir <directory> )
            # 在运行下级目录时，将当前工作目录设置为 <path>

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

## process load

```bash
(lldb) help process load
     # 将指定的共享库加载到当前进程中

Syntax: process load <filename> [<filename> ...]

Command Options Usage:
  process load [-i[<path>]]

       -i[<path>] ( --install=[<path>] )
            # 将共享库安装到 target
            # 如果不指定参数，则共享库将安装在当前工作目录中
```

## process plugin

```bash
(lldb) help process plugin
# 向当前目标进程的插件发送自定义命令
```

## process save-core

```bash
(lldb) help process save-core
     # 使用适当的文件类型将当前进程保存为核心文件(core file)

Syntax: process save-core FILE
```

## process signal

```bash
(lldb) help process signal
     # 向当前目标进程发送一个 UNIX 信号

Syntax: process signal <unix-signal>
```

## process status

```bash
(lldb) help process status
     # 显示当前目标进程的状态和暂停位置

Syntax: process status

Command Options Usage:
  process status [-v]

       -v ( --verbose )
            # 显示详细的进程状态，包括扩展的崩溃信息
```

## process unload

```bash
(lldb) help process unload
     # 使用之前调用 "process load" 命令所返回的索引，从当前进程中卸载指定的共享库

Syntax: process unload <index>
```

# quit

```bash
(lldb) help quit
     # 退出 LLDB 调试器

Syntax: quit [exit-code]
```

# register

```bash
(lldb) help register
     # 用于访问当前线程和栈帧的寄存器的命令
     # hcg 注:
	 # 寄存器(register)是跟线程(thread)相关的，想一下多核 CPU 与多线程的关系

Syntax: register [read|write] ...

The following subcommands are supported:

      read     # 从当前栈帧转储一个或多个寄存器的值
      	       # 如果未指定任何寄存器，则转储全部寄存器的值
      write    # 修改单个寄存器的值

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

## register read

```bash
(lldb) help register read
     # 从当前栈帧转储一个或多个寄存器的值
     # 如果未指定任何寄存器，则转储全部寄存器的值

Syntax: register read <cmd-options> [<register-name> [<register-name> [...]]]

Command Options Usage:
  register read [-A] [-f <format>] [-G <gdb-format>] [-s <index>] [<register-name> [<register-name> [...]]]
  register read [-Aa] [-f <format>] [-G <gdb-format>] [<register-name> [<register-name> [...]]]

       -A ( --alternate )
            # 如果有备用寄存器名称，则使用备用寄存器名称显示寄存器名称

       -G <gdb-format> ( --gdb-format <gdb-format> )
            # 使用(GDB 格式说明符字符串)指定格式

       -a ( --all )
            # 显示所有寄存器组(register sets)

       -f <format> ( --format <format> )
            # 指定用于显示的格式

       -s <index> ( --set <index> )
            # 通过索引 <index> 指定要转储的寄存器组(register sets)

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

## register write

```bash
(lldb) help register write
     # 修改单个寄存器的值

Syntax: register write <register-name> <value>
```

# reproducer

```bash
(lldb) help reproducer
     # 用于操作复制器的命令
     # 复制器可以捕获具有所有依赖项的完整调试会话
     # resulting 复制器用于在调试调试器时重放调试会话
     # 因为复制器需要从头到尾的整个调试会话，所以需要以捕获模式(capture mode)或重放模式(replay mode)启动调试器，通常通过命令行驱动程序启动
     # 因为复制器是不相关的记录-重放调试，所以在重放期间你不能与调试器交互

Syntax: reproducer <subcommand> [<subcommand-options>]

The following subcommands are supported:

      dump        # 转储复制器中包含的信息
      			  # 如果在重放期间没有指定要转储的复制器，则会转储当前复制器的内容
      generate    # 在磁盘上生成复制器
      			  # 当调试器处于捕获模式(capture mode)时，此命令会将复制器输出到磁盘上的目录并退出
      			  # 当调试器处于重放模式(replay mode)时，此命令不执行任何操作
      status      # 显示当前复制器的状态
      			  # 在捕获模式(capture mode)下，调试器会收集创建复制器所需的所有信息
      			  # 在重放模式(replay mode)下，复制器会重放调试会话
      			  # 当复制器关闭时，不会收集任何数据，也无法生成复制器
      xcrash      # 故意强制调试器崩溃以触发和测试复制器的生成

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

## reproducer dump

```bash
(lldb) help reproducer dump  
     # 转储复制器中包含的信息
     # 如果在重放期间没有指定要转储的复制器，则会转储当前复制器的内容

Syntax: reproducer dump <cmd-options>

Command Options Usage:
  reproducer dump -p <none> [-f <filename>]

       -f <filename> ( --file <filename> )
            # 复制器的路径
            # 如果复制器被重放并且未提供路径，则转储该复制器

       -p <none> ( --provider <none> )
            # 要转储的复制器的提供者
            # 可用值: commands | files | gdb | processes | version | cwd | none
```

## reproducer generate

```bash
(lldb) help reproducer generate
     # 在磁盘上生成复制器
     # 当调试器处于捕获模式(capture mode)时，此命令会将复制器输出到磁盘上的目录并退出
     # 当调试器处于重放模式(replay mode)时，此命令不执行任何操作

Syntax: reproducer generate
```

## reproducer status

```bash
(lldb) help reproducer status
     # 显示当前复制器的状态
     # 在捕获模式(capture mode)下，调试器会收集创建复制器所需的所有信息
     # 在重放模式(replay mode)下，复制器会重放调试会话
     # 当复制器关闭时，不会收集任何数据，也无法生成复制器

Syntax: reproducer status
```

## reproducer xcrash

```bash
(lldb) help reproducer xcrash
     # 故意强制调试器崩溃以触发和测试复制器的生成

Syntax: reproducer xcrash <cmd-options>

Command Options Usage:
  reproducer xcrash -s <none>

       -s <none> ( --signal <none> )
            # 使调试器崩溃的信号
            # 可用值: SIGILL | SIGSEGV
```

# script

```bash
(lldb) help script
     # 使用所提供的代码调用脚本解释器，并显示调用结果
     # 如果没有提供任何代码，则启动交互式解释器
     # 期望使用原始输入(请参阅 'help raw-input')

Syntax: script [<script-code>]
```

# settings

```bash
(lldb) help settings
     # 用于管理 LLDB 设置的命令

Syntax: settings <subcommand> [<command-options>]

The following subcommands are supported:

      append           # 将一个或多个值附加到调试器设置数组、设置字典或设置字符串中
      				   # 期望使用原始输入(请参阅 'help raw-input')
      clear            # 清除指定的调试器设置数组、设置字典或设置字符串
      insert-after     # 将一个或多个值插入到调试器设置数组中指定的元素索引之后
      				   # 期望使用原始输入(请参阅 'help raw-input')
      insert-before    # 将一个或多个值插入到调试器设置数组中指定的元素索引之前
        			   # 期望使用原始输入(请参阅 'help raw-input')
      list             # 列出并描述匹配的调试器设置
      				   # 默认为 all ，以列出所有调试器设置
      read             # 读取之前通过 "settings write" 命令保存到文件中的调试器设置
      remove           # 从调试器设置中删除由数组索引(array index)或字典键(dictionary key)所指定的值
      				   # 期望使用原始输入(请参阅 'help raw-input')
      replace          # 从调试器设置中替换由数组索引(array index)或字典键(dictionary key)所指定的值
          			   # 期望使用原始输入(请参阅 'help raw-input')
      set              # 设置指定调试器设置的值
                       # 期望使用原始输入(请参阅 'help raw-input')
      show             # 显示匹配的调试器设置及其当前值
      				   # 默认显示所有调试器设置
      write            # 将匹配的调试器设置和它们的当前值写入一个可以用 "settings read" 命令读取的文件中
                       # 默认为写入所有调试器设置

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

## settings append

```bash
(lldb) help settings append
     # 将一个或多个值附加到调试器设置数组、设置字典或设置字符串中
     # 期望使用原始输入(请参阅 'help raw-input')

Syntax: settings append <setting-variable-name> <value>
```

## settings clear

```bash
(lldb) help settings clear
     # 清除指定的调试器设置数组、设置字典或设置字符串

Syntax: settings clear <setting-variable-name>
```

## settings insert-after

```bash
(lldb) help settings insert-after
     # 将一个或多个值插入到调试器设置数组中指定的元素索引之后
     # 期望使用原始输入(请参阅 'help raw-input')

Syntax: settings insert-after <setting-variable-name> <setting-index> <value>
```

## settings insert-before

```bash
(lldb) help settings insert-before
     # 将一个或多个值插入到调试器设置数组中指定的元素索引之前
     # 期望使用原始输入(请参阅 'help raw-input')

Syntax: settings insert-before <setting-variable-name> <setting-index> <value>
```

## settings list

```bash
(lldb) help settings list
     # 列出并描述匹配的调试器设置
     # 默认为 all ，以列出所有调试器设置

Syntax: settings list [<setting-variable-name | setting-prefix>]
```

## settings read

```bash
(lldb) help settings read
     # 读取之前通过 "settings write" 命令保存到文件中的调试器设置

Syntax: settings read <cmd-options>

Command Options Usage:
  settings read -f <filename>

       -f <filename> ( --file <filename> )
            # 要从中读取调试器设置的文件
```

## settings remove

```bash
(lldb) help settings remove
     # 从调试器设置中删除由数组索引(array index)或字典键(dictionary key)所指定的值
     # 期望使用原始输入(请参阅 'help raw-input')

Syntax: settings remove <setting-variable-name> <setting-index | setting-key>
```

## settings replace

```bash
(lldb) help settings replace
     # 从调试器设置中替换由数组索引(array index)或字典键(dictionary key)所指定的值
     # 期望使用原始输入(请参阅 'help raw-input')

Syntax: settings replace <setting-variable-name> <setting-index | setting-key> <value>
```

## settings set

```bash
(lldb) help settings set
     # 设置指定调试器设置的值
     # 期望使用原始输入(请参阅 'help raw-input')

Syntax: settings set <cmd-options> -- <setting-variable-name> <value>

Command Options Usage:
  settings set [-f] [-g <filename>] -- <setting-variable-name> <value>
  settings set <setting-variable-name> <value>

       -f ( --force )
            # 强制接受一个空值作为默认值

       -g <filename> ( --global <filename> )
            # 将新值应用为全局默认值

# 在设置字典变量或数组变量时，可以通过将值传递给 set 命令来一次设置多个条目
# 例如:
(lldb) settings set target.run-args value1 value2 value3
(lldb) settings set target.env-vars MYPATH=~/.:/usr/bin  SOME_ENV_VAR=12345
(lldb) settings show target.run-args
  [0]: 'value1'
  [1]: 'value2'
  [2]: 'value3'
(lldb) settings show target.env-vars
  'MYPATH=~/.:/usr/bin'
  'SOME_ENV_VAR=12345'

# 警告:
# 'set' 命令会重新设置整个设置数组或设置字典
# 如果你只想添加、删除或更新单个值(或在末尾添加某些内容)，这请使用以下调试器设置的子命令之一:
# append、replace、insert-before、insert-after

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

## settings show

```bash
(lldb) help settings show
     # 显示匹配的调试器设置及其当前值
     # 默认显示所有调试器设置

Syntax: settings show [<setting-variable-name>]
```

## settings write

```bash
(lldb) help settings write
     # 将匹配的调试器设置和它们的当前值写入一个可以用 "settings read" 命令读取的文件中
	 # 默认为写入所有调试器设置

Syntax: settings export <cmd-options> [<setting-variable-name>]

Command Options Usage:
  settings export [-a] -f <filename> [<setting-variable-name>]

       -a ( --append )
            # 附加到已保存的调试器设置文件中(如果该文件存在的话)

       -f <filename> ( --file <filename> )
            # 要写入调试器设置的文件

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

# source

```bash
(lldb) help source
     # 用于检查由当前目标进程的调试信息所描述的源代码的命令

Syntax: source <subcommand> [<subcommand-options>]

The following subcommands are supported:

      info    # 显示当前目标进程的源代码行信息
     		  # 默认为当前栈帧中的指令指针寄存器(IP)所指向的内容(对于 x86 架构)
     		  # 默认为当前栈帧中的程序计数寄存器(PC)所指向的内容(对于 arm 架构)
      list    # 显示由选项指定的当前目标进程的源代码

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

## source info

```bash
(lldb) help source info
     # 显示当前目标进程的源代码行信息
     # 默认为当前栈帧中的指令指针寄存器(IP)所指向的内容(对于 x86 架构)
     # 默认为当前栈帧中的程序计数寄存器(PC)所指向的内容(对于 arm 架构)

Syntax: source info <cmd-options>

Command Options Usage:
  source info [-c <count>] [-e <linenum>] [-f <filename>] [-l <linenum>] [-s <shlib-name>]
  source info [-c <count>] [-n <symbol>] [-s <shlib-name>]
  source info [-a <address-expression>] [-c <count>]

       -a <address-expression> ( --address <address-expression> )
            # 查找指定的地址并显示相应文件和行的源代码信息

       -c <count> ( --count <count> )
            # 要显示的源代码的行数

       -e <linenum> ( --end-line <linenum> )
            # 要结束显示源代码的行号

       -f <filename> ( --file <filename> )
            # 要显示源代码的文件

       -l <linenum> ( --line <linenum> )
            # 要开始显示源代码的行号

       -n <symbol> ( --name <symbol> )
            # 要显示其源代码的函数的名称

       -s <shlib-name> ( --shlib <shlib-name> )
            # 在给定的模块或共享库中查找源代码
            # 可以多次重复此选项以指定多个模块或共享库
```

## source list

```bash
(lldb) help source list
     # 显示由选项指定的当前目标进程的源代码

Syntax: source list <cmd-options>

Command Options Usage:
  source list [-b] [-c <count>] [-f <filename>] [-l <linenum>] [-s <shlib-name>]
  source list [-b] [-c <count>] [-n <symbol>] [-s <shlib-name>]
  source list [-b] [-a <address-expression>] [-c <count>]
  source list [-br] [-c <count>]

       -a <address-expression> ( --address <address-expression> )
            # 查找指定的地址并显示相应文件和行的源代码信息

       -b ( --show-breakpoints )
            # 显示调试信息中的行表位置(line table location)，这些行表位置(line table location)用于指示设置源代码级别的断点的有效位置

       -c <count> ( --count <count> )
            # 要显示的源代码的行数

       -f <filename> ( --file <filename> )
            # 要显示源代码的文件

       -l <linenum> ( --line <linenum> )
            # 要开始显示源代码的行号

       -n <symbol> ( --name <symbol> )
            # 要显示其源代码的函数的名称

       -r ( --reverse )
            # 反转列表以从最后显示的源代码块方向查看

       -s <shlib-name> ( --shlib <shlib-name> )
            # 在给定的模块或共享库中查找源代码
            # 可以多次重复此选项以指定多个模块或共享库
```

# statistics

```bash
(lldb) help statistics
     # 用于打印有关调试会话的统计信息

Syntax: statistics <subcommand> [<subcommand-options>]

The following subcommands are supported:

      disable    # 禁用统计信息收集
      dump       # 转储统计结果
      enable     # 启用统计信息收集

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

## statistics disable

```bash
(lldb) help statistics disable
     # 禁用统计信息收集

Syntax: disable
```

## statistics dump

```bash
(lldb) help statistics dump
     # 转储统计结果

Syntax: dump
```

## statistics enable

```bash
(lldb) help statistics enable
     # 启用统计信息收集

Syntax: enable
```

# target

```bash
(lldb) help target
     # 用于对调试器 target 进行操作的命令

Syntax: target <subcommand> [<subcommand-options>]

The following subcommands are supported:

      create                     # 使用指定的参数来创建一个 target 以作为主可执行文件
      delete                     # 通过 target 索引删除一个或多个 target
      list                       # 列出当前调试会话中所有的当前 target
      modules                    # 用于访问一个或多个 target 的模块的信息的命令
      select                     # 通过 target 索引选择一个 target 作为当前的 target
      show-launch-environment    # 显示启动时传递给进程的环境变量，采用以下设置:
								 # target.env-vars、target.inherit-env、target.unset-env-vars
      stop-hook                  # 用于在调试器的 target 的 stop-hook 上执行的命令
      symbols                    # 用于添加和管理调试符号文件的命令
      variable                   # 在运行进程之前或运行进程时，读取当前 target 的全局变量

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

## target create

```bash
(lldb) help target create
     # 使用指定的参数来创建一个 target 以作为主可执行文件

Syntax: target create <cmd-options> <filename>

Command Options Usage:
  target create [-a <arch>] [-c <filename>] [-P <path>] [-s <filename>] [-r <filename>] [-d[<value>]] <filename>

       -P <path> ( --platform-path <path> )
            # 用于此 target 的远程文件(remote file)的路径

       -a <arch> ( --arch <arch> )
            # 指定 target 的 CPU 体系结构

       -c <filename> ( --core <filename> )
            # 用于此 target 的核心文件(core file)的完整路径

       -d[<value>] ( --no-dependents=[<value>] )
            # 在创建 target 时是否加载依赖项
            # 如果未指定该选项，则该值隐式为 default
            # 如果指定了选项但是没有指定值，则该值隐式为 true
            # 可用值: default | true | false

       -r <filename> ( --remote-file <filename> )
            # 如果进行远程调试，则为远程主机上的文件的完整路径

       -s <filename> ( --symfile <filename> )
            # 当调试符号不在可执行文件中时，到独立调试符号文件的完整路径

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

## target delete

```bash
(lldb) help target delete
     # 通过 target 索引删除一个或多个 target

Syntax: target delete <cmd-options>

Command Options Usage:
  target delete [-ac]

       -a ( --all )
            # 删除所有 target

       -c ( --clean )
            # 删除 target 后执行额外的清理以最小化内存消耗
            # 默认情况下，LLDB 会将 target 先前加载的任何模块及其所有调试信息保存在内存中
            # 指定 --clean 选项将卸载所有这些共享模块，并在下次运行 target 时再次重新解析它们
```

## target list

```bash
(lldb) help target list
     # 列出当前调试会话中所有的当前 target

Syntax: target list
```

## target modules

```bash
(lldb) help target modules
     # 用于访问一个或多个 target 的模块的信息的命令

Syntax: target modules <sub-command> ...

The following subcommands are supported:

      add             # 将新模块添加到当前 target 的模块列表中
      dump            # 用于转储一个或多个 target 的模块的信息的命令
      list            # 列出当前的可执行文件和其依赖的共享库的镜像
      load         	  # 为 target 的模块中的一个或多个 section 设置加载地址
      lookup          # 在可执行文件和其依赖的共享库的镜像中查找信息
      search-paths    # 用于管理 target 的模块搜索路径的命令
      show-unwind     # 显示函数或符号的展开指令(unwind instruction)

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

### target modules add

```bash
(lldb) help target modules add
     # 将新模块添加到当前 target 的模块列表中

Syntax: target modules add [<module>]

Command Options Usage:
  target modules add [-u <none>] [-s <filename>]

       -s <filename> ( --symfile <filename> )
            # 当调试符号不在可执行文件中时，到独立调试符号文件的完整路径

       -u <none> ( --uuid <none> )
            # 模块的 UUID 值
```

### target modules dump

```bash
(lldb) help target modules dump
     # 用于转储一个或多个 target 的模块的信息的命令

Syntax: target modules dump [headers|symtab|sections|ast|symfile|line-table] [<file1> <file2> ...]

The following subcommands are supported:

      ast           # 转储指定模块的符号文件的 Clang AST
      line-table    # 转储一个或多个编译单元的行表(line table)
      objfile       # 从一个或多个 target 的模块转储目标文件的头(object file header)
      sections      # 从一个或多个 target 的模块转储节(section)
      symfile       # 从一个或多个 target 的模块转储调试符号文件(debug symbol file)
      symtab        # 从一个或多个 target 的模块转储符号表(symbol table)

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

#### target modules dump ast

```bash
(lldb) help target modules dump ast
     # 转储指定模块的符号文件的 Clang AST

Syntax: target modules dump ast [<filename> [<filename> [...]]]
```

#### target modules dump line-table

```bash
(lldb) help target modules dump line-table
     # 转储一个或多个编译单元的行表(line table)

Syntax: target modules dump line-table <cmd-options> <source-file> [<source-file> [...]]

Command Options Usage:
  target modules dump line-table [-v] <source-file> [<source-file> [...]]

       -v ( --verbose )
            # 启用详细转储

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

#### target modules dump objfile

```bash
(lldb) help target modules dump objfile
     # 从一个或多个 target 的模块转储目标文件的头(object file header)

Syntax: target modules dump objfile [<filename> [<filename> [...]]]
```

#### target modules dump sections

```bash
(lldb) help target modules dump sections
     # 从一个或多个 target 的模块转储节(section)

Syntax: target modules dump sections [<filename> [<filename> [...]]]
```

#### target modules dump symfile

```bash
(lldb) help target modules dump symfile
     # 从一个或多个 target 的模块转储调试符号文件(debug symbol file)

Syntax: target modules dump symfile [<filename> [<filename> [...]]]
```

#### target modules dump symtab

```bash
(lldb) help target modules dump symtab
     # 从一个或多个 target 的模块转储符号表(symbol table)

Syntax: target modules dump symtab <cmd-options> [<filename> [<filename> [...]]]

Command Options Usage:
  target modules dump symtab [-m] [-s <sort-order>] [<filename> [<filename> [...]]]

       -m ( --show-mangled-names )
            # 在显示之前不要对符号名称进行 demangle

       -s <sort-order> ( --sort <sort-order> )
            # 在转储符号表时，提供排序顺序
            # 可用值: none | address | name

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

### target modules list

```bash
(lldb) help target modules list
     # 列出当前的可执行文件和其依赖的共享库的镜像

Syntax: target modules list [<cmd-options>]

Command Options Usage:
  target modules list [-ghou] [-a <address-expression>] [-A[<width>]] [-b[<width>]] [-d[<width>]] [-f[<width>]] [-m[<width>]] [-p[<none>]] [-r[<width>]] [-s[<width>]] [-S[<width>]] [-t[<width>]]

       -A[<width>] ( --arch=[<width>] )
            # 在列出镜像时，显示 CPU 架构
            # 具有可选的显示宽度

       -S[<width>] ( --symfile-unique=[<width>] )
            # 仅当符号文件与可执行目标文件不同时，才显示符号文件
            # 具有可选的显示宽度

       -a <address-expression> ( --address <address-expression> )
            # 显示包含此地址的镜像

       -b[<width>] ( --basename=[<width>] )
            # 显示镜像目标文件的基本名称
            # 具有可选的显示宽度

       -d[<width>] ( --directory=[<width>] )
            # 显示镜像目标文件的目录
            # 具有可选的显示宽度

       -f[<width>] ( --fullpath=[<width>] )
            # 显示镜像目标文件的全路径
            # 具有可选的显示宽度

       -g ( --global )
            # 显示全局模块列表中的模块，而不仅仅是当前 target 的模块

       -h ( --header )
            # 如果处于调试状态，则将镜像的基地址显示为加载地址
            # 否则，显示为文件地址

       -m[<width>] ( --mod-time=[<width>] )
            # 显示模块的修改时间
            # 具有可选的显示宽度

       -o ( --offset )
            # 显示镜像加载地址相对于文件基地址的偏移量(即 slide)

       -p[<none>] ( --pointer=[<none>] )
            # 显示模块指针

       -r[<width>] ( --ref-count=[<width>] )
            # 如果模块仍在共享模块缓存中，则显示其引用计数
            # 具有可选的显示宽度

       -s[<width>] ( --symfile=[<width>] )
            # 显示镜像符号文件的完整路径
            # 具有可选的显示宽度

       -t[<width>] ( --triple=[<width>] )
            # 在列出镜像时，显示三元组
            # 具有可选的显示宽度

       -u ( --uuid )
            # 在列出镜像时，显示 UUID
```

### target modules load

```bash
(lldb) help target modules load
     # 为 target 的模块中的一个或多个 section 设置加载地址

Syntax: target modules load [--file <module> --uuid <uuid>] <sect-name> <address> [<sect-name> <address> ....]

Command Options Usage:
  target modules load [-lp] [-u <none>] [-f <name>] [-s <offset>] [<filename> [<filename> [...]]]

       -f <name> ( --file <name> )
            # 要加载的模块的完整路径或基本名称

       -l ( --load )
            # 将文件内容写入到内存中

       -p ( --set-pc-to-entry )
            # 将 PC 寄存器设置为入口点
            # 仅适用于 '--load' 选项

       -s <offset> ( --slide <offset> )
            # 将所有节(section)的加载地址设置为文件中的虚拟地址加上偏移量 <offset>

       -u <none> ( --uuid <none> )
            # 模块 UUID 值

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

### target modules lookup

```bash
(lldb) help target modules lookup
     # 在可执行文件和其依赖的共享库的镜像中查找信息

Syntax: target modules lookup <cmd-options> [<filename> [<filename> [...]]]

Command Options Usage:
  target modules lookup [-Av] -a <address-expression> [-o <offset>] [<filename> [<filename> [...]]]
  target modules lookup [-Arv] -s <symbol> [<filename> [<filename> [...]]]
  target modules lookup [-Aiv] -f <filename> [-l <linenum>] [<filename> [<filename> [...]]]
  target modules lookup [-Airv] -F <function-name> [<filename> [<filename> [...]]]
  target modules lookup [-Airv] -n <function-or-symbol> [<filename> [<filename> [...]]]
  target modules lookup [-Av] -t <name> [<filename> [<filename> [...]]]

       -A ( --all )
            # 如果存在最佳匹配项，则打印所有匹配项，而不仅仅是打印最佳匹配项

       -F <function-name> ( --function <function-name> )
            # 在一个或多个 target 的模块的调试符号中按指定名称查找函数

       -a <address-expression> ( --address <address-expression> )
            # 在一个或多个 target 的模块中查找指定的地址

       -f <filename> ( --file <filename> )
            # 在一个或多个 target 的模块中按完整路径或基本名称查找文件

       -i ( --no-inlines )
            # 忽略内联条目(必须与 --file 或 --function 结合使用)

       -l <linenum> ( --line <linenum> )
            # 在文件中查找行号(必须与 --file 结合使用)

       -n <function-or-symbol> ( --name <function-or-symbol> )
            # 在一个或多个 target 的模块中按名称查找函数或符号

       -o <offset> ( --offset <offset> )
            # 在查找地址时，在查找之前从所有地址中减去指定的偏移量 <offset>

       -r ( --regex )
            # 根据名称查找的 <name> 参数是正则表达式

       -s <symbol> ( --symbol <symbol> )
            # 在一个或多个 target 的模块的符号表中按名称查找符号

       -t <name> ( --type <name> )
            # 在一个或多个 target 的模块的调试符号中按名称查找类型

       -v ( --verbose )
            # 启用详细查找信息

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

### target modules search-paths

```bash
(lldb) help target modules search-paths
     # 用于管理 target 的模块搜索路径的命令

Syntax: target modules search-paths <subcommand> [<subcommand-options>]

The following subcommands are supported:

      add       # 向当前 target 添加新的镜像搜索路径替换对(image search paths substitution pairs)
      clear     # 从当前 target 清除所有当前的镜像搜索路径替换对(image search paths substitution pairs)
      insert    # 将新的镜像搜索路径替换对(image search paths substitution pairs)插入到当前 target 中指定的索引处
      list      # 列出当前 target 中所有当前的镜像搜索路径替换对(image search paths substitution pairs)
      query     # 使用第一个适用的镜像搜索路径转换路径

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

#### target modules search-paths add

```bash
(lldb) help target modules search-paths add
     # 向当前 target 添加新的镜像搜索路径替换对(image search paths substitution pairs)

Syntax: target modules search-paths add <old-path-prefix> <new-path-prefix> [<old-path-prefix> <new-path-prefix> [...]]
```

#### target modules search-paths clear

```bash
(lldb) help target modules search-paths clear
     # 从当前 target 清除所有当前的镜像搜索路径替换对(image search paths substitution pairs)

Syntax: target modules search-paths clear
```

#### target modules search-paths insert

```bash
(lldb) help target modules search-paths insert
     # 将新的镜像搜索路径替换对(image search paths substitution pairs)插入到当前 target 中指定的索引处

Syntax: target modules search-paths insert <index> <old-path-prefix> <new-path-prefix> [<old-path-prefix> <new-path-prefix> [...]]
```

#### target modules search-paths list

```bash
(lldb) help target modules search-paths list
     # 列出当前 target 中所有当前的镜像搜索路径替换对(image search paths substitution pairs)

Syntax: target modules search-paths list
```

#### target modules search-paths query

```bash
(lldb) help target modules search-paths query
     # 使用第一个适用的镜像搜索路径转换路径

Syntax: target modules search-paths query <directory>
```

### target modules show-unwind

```bash
(lldb) help target modules show-unwind
     # 显示函数或符号的展开指令(unwind instruction)

Syntax: target modules show-unwind <cmd-options>

Command Options Usage:
  target modules show-unwind [-n <function-name>]
  target modules show-unwind [-a <address-expression>]

       -a <address-expression> ( --address <address-expression> )
            # 显示包含指定地址的函数或符号的展开指令(unwind instruction)

       -n <function-name> ( --name <function-name> )
            # 显示指定的函数名称或符号名称的展开指令(unwind instruction)
```

## target select

```bash
(lldb) help target select
     # 通过 target 索引选择一个 target 作为当前的 target

Syntax: target select
```

## target show-launch-environment

```bash
(lldb) help target show-launch-environment
     # 显示启动时传递给进程的环境变量，采用以下设置:
     # target.env-vars、target.inherit-env、target.unset-env-vars

Syntax: target show-launch-environment
```

## target stop-hook

```bash
(lldb) help target stop-hook
     # 用于在调试器的 target 的 stop-hook 上执行的命令

Syntax: target stop-hook <subcommand> [<subcommand-options>]

The following subcommands are supported:

      add        # 添加一个在 target 暂停时执行的 stop-hook
      delete     # 删除指定的 stop-hook
      disable    # 禁用 stop-hook
      enable     # 启用 stop-hook
      list       # 列出所有的 stop-hook

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

### target stop-hook add

```bash
(lldb) help target stop-hook add
     # 添加一个在 target 暂停时执行的 stop-hook

Syntax: target stop-hook add

Command Options Usage:
  target stop-hook add [-G <boolean>] [-e <linenum>] [-f <filename>] [-o <one-line-command>] [-q <queue-name>] [-s <shlib-name>] [-l <linenum>] [-t <thread-id>] [-x <thread-index>] [-T <thread-name>]
  target stop-hook add [-G <boolean>] [-c <class-name>] [-o <one-line-command>] [-q <queue-name>] [-s <shlib-name>] [-t <thread-id>] [-x <thread-index>] [-T <thread-name>]
  target stop-hook add [-G <boolean>] [-n <function-name>] [-o <one-line-command>] [-q <queue-name>] [-s <shlib-name>] [-t <thread-id>] [-x <thread-index>] [-T <thread-name>]

       -G <boolean> ( --auto-continue <boolean> )
            # 断点将在运行其命令后自动继续

       -T <thread-name> ( --thread-name <thread-name> )
            # stop-hook 仅针对线程名称与此参数匹配的线程运行

       -c <class-name> ( --classname <class-name> )
            # 指定要在其中运行 stop-hook 的类
            # hcg 注: stop-hook 仅在 <class-name> 指定的类中会生效

       -e <linenum> ( --end-line <linenum> )
            # 设置要运行 stop-hook 的行范围的结尾

       -f <filename> ( --file <filename> )
            # 指定要在其中运行 stop-hook 的源文件
            # hcg 注: stop-hook 仅在 <filename> 指定的源文件中生效

       -l <linenum> ( --start-line <linenum> )
            # 设置要运行 stop-hook 的行范围的开始

       -n <function-name> ( --name <function-name> )
            # 指定要在其中运行 stop-hook 的函数名称
            # hcg 注: stop-hook 仅在 <function-name> 指定的函数中生效

       -o <one-line-command> ( --one-liner <one-line-command> )
            # 为 stop-hook 添加一条命令
            # 可以多次重复此选项以添加多条命令，并且添加的命令将按照它们的添加顺序执行

       -q <queue-name> ( --queue-name <queue-name> )
            # stop-hook 仅针对队列名称与此参数匹配的线程运行

       -s <shlib-name> ( --shlib <shlib-name> )
            # 指定要在其中运行 stop-hook 的模块
            # hcg 注: stop-hook 仅在 <shlib-name> 指定的共享库中生效

       -t <thread-id> ( --thread-id <thread-id> )
            # stop-hook 仅针对线程 ID 与此参数匹配的线程运行

       -x <thread-index> ( --thread-index <thread-index> )
            # stop-hook 仅针对线程索引与此参数匹配的线程运行
```

### target stop-hook delete

```bash
(lldb) help target stop-hook delete
     # 删除指定的 stop-hook

Syntax: target stop-hook delete [<idx>]
```

### target stop-hook disable

```bash
(lldb) help target stop-hook disable
     # 禁用 stop-hook

Syntax: target stop-hook disable
```

### target stop-hook enable

```bash
(lldb) help target stop-hook enable
     # 启用 stop-hook

Syntax: target stop-hook enable
```

### target stop-hook list

```bash
(lldb) help target stop-hook list
     # 列出所有的 stop-hook

Syntax: target stop-hook list [<type>]
```

## target symbols

```bash
(lldb) help target symbols
     # 用于添加和管理调试符号文件的命令

Syntax: target symbols <sub-command> ...

The following subcommands are supported:

      add    # 通过指定调试符号文件的路径或使用选项指定要为其下载符号的模块，将调试符号文件添加到 target 的当前模块之一

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

### target symbols add

```bash
(lldb) help target symbols add
     # 通过指定调试符号文件的路径或使用选项指定要为其下载符号的模块，将调试符号文件添加到 target 的当前模块之一

Syntax: target symbols add <cmd-options> [<symfile>]

Command Options Usage:
  target symbols add [-u <none>] [-s <shlib-name>]
  target symbols add [-F]

       -F ( --frame )
            # 定位到当前选定的栈帧的调试符号

       -s <shlib-name> ( --shlib <shlib-name> )
            # 要为其查找调试符号的模块的完整路径或基本名称

       -u <none> ( --uuid <none> )
            # 模块 UUID 值
```

## target variable

```bash
(lldb) help target variable
     # 在运行进程之前或运行进程时，读取当前 target 的全局变量

Syntax: target variable <cmd-options> <variable-name> [<variable-name> [...]]

Command Options Usage:
  target variable [-AFLORTcgrs] [-d <none>] [-S <boolean>] [-D <count>] [-P <count>] [-Y[<count>]] [-V <boolean>] [-Z <count>] [-y <name>] [-z <name>] [-f <format>] [-G <gdb-format>] [--file <filename>] [--shlib <filename>] <variable-name> [<variable-name> [...]]

       -A ( --show-all-children )
             # 显示所有子项
             # 忽略要显示的子项数量的上限

       -D <count> ( --depth <count> )
            # 转储聚合类型时设置最大递归深度(默认为无穷大)

       -F ( --flat )
            # 为每个变量或成员使用表达式路径的扁平格式显示结果

       -G <gdb-format> ( --gdb-format <gdb-format> )
            # 使用(GDB 格式说明符字符串)指定格式

       -L ( --location )
            # 显示变量的位置信息(内存地址或寄存器名称)

       -O ( --object-description )
            # 如果可能，使用特定于语言的描述 API 显示结果
            # 对于 Objective-C 来说，就是调用类对象或实例对象的 description 方法

       -P <count> ( --ptr-depth <count> )
            # 转储值时要遍历的指针数(默认为零)

       -R ( --raw-output )
            # 不要使用格式选项(即，使用原始输出格式)

       -S <boolean> ( --synthetic-type <boolean> )
            # 显示符合其合成提供程序的对象(如果可用)

       -T ( --show-types )
            # 转储值时显示变量的类型

       -V <boolean> ( --validate <boolean> )
            # 显示类型验证器的结果

       -Y[<count>] ( --no-summary-depth=[<count>] )
            # 设置省略摘要信息停止的深度(默认为 1)

       -Z <count> ( --element-count <count> )
            # 将表达式的结果视为其类型是包含 <count> 个元素的数组

       -c ( --show-declaration )
            # 显示变量的声明信息(声明变量的源文件和行)

       -d <none> ( --dynamic-type <none> )
            # 如果可用，则将对象显示为其完整的动态类型，而不是其静态类型
            # 可用值: no-dynamic-values | run-target | no-run-target

       -f <format> ( --format <format> )
            # 指定用于显示的格式

       -g ( --show-globals )
            # 显示当前栈帧的源文件的全局变量和静态变量

       -r ( --regex )
            # 名称查找的参数 <variable-name> 是正则表达式

       -s ( --scope )
            # 显示变量的作用域: argument(参数)、local(局部变量)、global(全局变量)、static(静态变量)

       -y <name> ( --summary <name> )
            # 指定变量输出应使用的摘要

       -z <name> ( --summary-string <name> )
            # 指定用于格式化变量输出的摘要字符串

       --file <filename>
            # 包含全局变量的文件的基本名称或完整路径
            # 可以多次重复此选项以指定多个文件

       --shlib <filename>
            # 用于搜索全局变量的共享库的基本名称或完整路径
            # 可以多次重复此选项以指定多个共享库

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

# thread

```bash
(lldb) help thread
     # 用于操作当前进程中的一个或多个线程的命令

Syntax: thread <subcommand> [<subcommand-options>]

The following subcommands are supported:

      backtrace         # 显示线程调用栈
                        # 默认为当前线程，可以指定线程索引作为参数
                        # 使用线程索引 "all" 查看所有线程
                        # 使用线程索引 "unique" 查看按唯一调用栈分组的线程
                        # 使用 'settings set frame-format' 自定义堆栈回溯中栈帧的打印格式
                        # 使用 'settings set thread-format' 自定义堆栈回溯中线程 header 的打印格式
      continue          # 继续执行当前目标进程
      					# 可以指定一个或多个线程，默认情况下所有线程都继续执行
      exception         # 显示线程的当前异常对象
                        # 默认为当前线程
      info              # 显示一个或多个线程的扩展摘要
                        # 默认为当前线程
      jump              # 将程序计数器(PC 寄存器)设置为新地址
      list              # 显示当前目标进程中每个线程的摘要
      					# 使用 'settings set thread-format' 自定义线程列表的输出格式
      plan              # 管理用于控制执行的线程计划
      return            # 提前从栈帧返回，短路较新帧的执行，并可选择地产生一个指定的值作为返回值
      					# 默认为退出当前栈帧
      					# 期望使用原始输入(请参阅 'help raw-input')
      select            # 更改当前选定的线程
      step-in           # 源码级别的单步执行，会进入函数或方法的调用
                        # 除非指定，否则默认为当前线程
      step-inst         # 汇编指令级别的单步执行，会进入汇编函数的调用
                        # 除非指定，否则默认为当前线程
      step-inst-over    # 汇编指令级别的单步执行，会跨过汇编函数的调用
                        # 除非指定，否则默认为当前线程
      step-out          # 执行完当前栈帧，并在返回后暂停
      					# 除非指定，否则默认为当前线程
      step-over         # 源码级别的单步执行，会跨过函数或方法的调用
                        # 除非指定，否则默认为当前线程
      step-scripted     # 按照 -C 选项中传递的脚本类的指示执行单步操作
       					# 你还可以指定将用于填充 SBStructuredData 字典的键(-k)值(-v)对，该字典将传递给实现执行单步脚本的类的构造函数
       					# 有关更多详细信息，请参阅 Python Reference
      until             # 继续执行直到当前线程或指定线程到达指定行号或指定地址
      					# 作为安全措施，从当前函数返回时也会暂停
      					# 目标行号​​作为参数给出，如果提供了多个行号，则当第一个行号被命中时，执行将暂停

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

## thread backtrace

```bash
(lldb) help thread backtrace
     # 显示线程调用栈
	 # 默认为当前线程，可以指定线程索引作为参数
	 # 使用线程索引 "all" 查看所有线程
	 # 使用线程索引 "unique" 查看按唯一调用栈分组的线程
	 # 使用 'settings set frame-format' 自定义堆栈回溯中栈帧的打印格式
	 # 使用 'settings set thread-format' 自定义堆栈回溯中线程 header 的打印格式

Syntax: thread backtrace <cmd-options>

Command Options Usage:
  thread backtrace [-c <count>] [-e <boolean>] [-s <frame-index>]

       -c <count> ( --count <count> )
            # 要显示多少栈帧(如果要显示所有栈帧，则传递 -1)

       -e <boolean> ( --extended <boolean> )
            # 显示扩展的回溯(如果有)

       -s <frame-index> ( --start <frame-index> )
            # 要开始回溯的栈帧的索引
```

## thread continue

```bash
(lldb) help thread continue
     # 继续执行当前目标进程
     # 可以指定一个或多个线程，默认情况下所有线程都继续执行

Syntax: thread continue <thread-index> [<thread-index> [...]]
```

## thread exception

```bash
(lldb) help thread exception
     # 显示线程的当前异常对象
     # 默认为当前线程

Syntax: thread exception
```

## thread info

```bash
(lldb) help thread info
     # 显示一个或多个线程的扩展摘要
	 # 默认为当前线程

Syntax: thread info

Command Options Usage:
  thread info [-js]

       -j ( --json )
            # 以 JSON 格式显示线程信息

       -s ( --stop-info )
            # 以 JSON 格式显示扩展暂停信息
```

## thread jump

```bash
(lldb) help thread jump
     # 将程序计数器(PC 寄存器)设置为新地址

Syntax: thread jump

Command Options Usage:
  thread jump [-r] -l <linenum> [-f <filename>]
  thread jump [-r] -b <offset>
  thread jump [-r] -a <address-expression>

       -a <address-expression> ( --address <address-expression> )
            # 跳转到指定地址

       -b <offset> ( --by <offset> )
            # 跳转到相对当前行偏移 offset 的行处

       -f <filename> ( --file <filename> )
            # 指定要跳转到的源文件

       -l <linenum> ( --line <linenum> )
            # 指定要跳转到的行号

       -r ( --force )
            # 允许 PC 寄存器离开当前函数
```

## thread list

```bash
(lldb) help thread list
     # 显示当前目标进程中每个线程的摘要
     # 使用 'settings set thread-format' 自定义线程列表的输出格式

Syntax: thread list
```

## thread plan

```bash
(lldb) help thread plan
     # 管理用于控制执行的线程计划

Syntax: thread plan <subcommand> [<subcommand objects]

The following subcommands are supported:

      discard    # 废弃直到(并包括)指定索引的线程计划(请参阅 'thread plan list')
      		     # 只能废弃用户可见的线程计划
      list       # 显示一个或多个线程的线程计划
      			 # 如果未指定任何线程，则显示当前线程的线程计划
      			 # 使用线程索引 "all" 查看所有线程的线程计划
      prune      # 删除与当前未报告的线程关联的任何线程计划
      		     # 指定一个或多个要删除的 TID，或者如果没有指定任何 TID，则删除所有未报告线程的线程计划

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

### thread plan discard

```bash
(lldb) help thread plan discard
     # 废弃直到(并包括)指定索引的线程计划(请参阅 'thread plan list')
     # 只能废弃用户可见的线程计划

Syntax: thread plan discard <unsigned-integer>
```

### thread plan list

```bash
(lldb) help thread plan list
     # 显示一个或多个线程的线程计划
     # 如果未指定任何线程，则显示当前线程的线程计划
     # 使用线程索引 "all" 查看所有线程的线程计划

Syntax: thread plan list <cmd-options>

Command Options Usage:
  thread plan list [-iuv] [-t <thread-id>]

       -i ( --internal )
            # 显示内部线程计划和用户线程计划

       -t <thread-id> ( --thread-id <thread-id> )
            # 列出此 TID 的线程计划
            # 可以多次重复此选项以指定多个线程

       -u ( --unreported )
            # 显示未报告线程的线程计划

       -v ( --verbose )
            # 显示有关线程计划的更多信息
```

### thread plan prune

```bash
(lldb) help thread plan prune
     # 删除与当前未报告的线程关联的任何线程计划
     # 指定一个或多个要删除的 TID，或者如果没有指定任何 TID，则删除所有未报告线程的线程计划

Syntax: thread plan prune [<thread-id> [<thread-id> [...]]]
```

## thread return

```bash
(lldb) help thread return
     # 提前从栈帧返回，短路较新帧的执行，并可选择地产生一个指定的值作为返回值
     # 默认为退出当前栈帧
     # 期望使用原始输入(请参阅 'help raw-input')

Syntax: thread return

Command Options Usage:
  thread return [-x] -- [<expr>]
  thread return [<expr>]

       -x ( --from-expression )
            # 执行表达式并获取执行结果作为返回值
# hcg 注:
# thread return 命令有一个可选参数，在执行 thread return 命令时，LLDB 会把可选参数加载进返回寄存器里，然后立刻执行返回指令，跳出当前栈帧
# 这意味着函数的剩余部分不会被执行，这可能会给 ARC 的引用计数造成一些问题，或者会使函数内的清理部分失效
# 但是在函数的开头执行 thread return 命令，是个非常好的隔离目标函数、伪造返回值的方式

# 重要提示:
# 因为这个命令需要原始输入，所以如果你使用任何命令选项，则你必须在命令选项的末尾和原始输入的开始之间使用 ' -- ' 分隔
```

## thread select

```bash
(lldb) help thread select
     # 更改当前选定的线程

Syntax: thread select <thread-index>
```

## thread step-in

```bash
(lldb) help thread step-in
     # 源码级别的单步执行，会进入函数或方法的调用
     # 除非指定，否则默认为当前线程

Syntax: thread step-in <cmd-options> [<thread-id>]

Command Options Usage:
  thread step-in [-c <count>] [-e <linenum>] [-m <run-mode>] [-a <boolean>] [-t <function-name>] [-A <boolean>] [-r <regular-expression>] [<thread-id>]

       -A <boolean> ( --step-out-avoids-no-debug <boolean> )
            # 一个布尔值，如果为 true，则跳出函数时将继续跳出，直到它遇到一个带有调试信息的函数

       -a <boolean> ( --step-in-avoids-no-debug <boolean> )
            # 一个布尔值，用于设置在单步执行函数时，是否将单步执行没有调试信息的函数

       -c <count> ( --count <count> )
            # 执行步进操作的次数 - 目前仅支持 step-inst 和 next-inst

       -e <linenum> ( --end-linenumber <linenum> )
            # 要暂停步进的行号 - 默认为下一行，仅支持 step-in 和 step-over
            # 你还可以传递字符串 'block' 以步进到当前 block 的末尾
            # 这特别适合与 --step-target 结合使用，以逐步执行复杂的调用序列

       -m <run-mode> ( --run-mode <run-mode> )
            # 确定在单步执行当前线程的同时，如何运行其他线程
            # 可用值: this-thread | all-threads | while-stepping

       -r <regular-expression> ( --step-over-regexp <regular-expression> )
			# 一个正则表达式，它定义了在 step-in 时不暂停的函数的名称

       -t <function-name> ( --step-in-target <function-name> )
            # 直接调用的函数的名称，step in 应该在 step into 时暂停

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

## thread step-inst

```bash
(lldb) help thread step-inst
     # 汇编指令级别的单步执行，会进入汇编函数的调用
     # 除非指定，否则默认为当前线程

Syntax: thread step-inst <cmd-options> [<thread-id>]

Command Options Usage:
  thread step-inst [-c <count>] [-e <linenum>] [-m <run-mode>] [-a <boolean>] [-t <function-name>] [-A <boolean>] [-r <regular-expression>] [<thread-id>]

       -A <boolean> ( --step-out-avoids-no-debug <boolean> )
            # 一个布尔值，如果为 true，则跳出函数时将继续跳出，直到它遇到一个带有调试信息的函数

       -a <boolean> ( --step-in-avoids-no-debug <boolean> )
            # 一个布尔值，用于设置在单步执行函数时，是否将单步执行没有调试信息的函数

       -c <count> ( --count <count> )
            # 执行步进操作的次数 - 目前仅支持 step-inst 和 next-inst

       -e <linenum> ( --end-linenumber <linenum> )
            # 要暂停步进的行号 - 默认为下一行，仅支持 step-in 和 step-over
            # 你还可以传递字符串 'block' 以步进到当前 block 的末尾
            # 这特别适合与 --step-target 结合使用，以逐步执行复杂的调用序列

       -m <run-mode> ( --run-mode <run-mode> )
            # 确定在单步执行当前线程的同时，如何运行其他线程
            # 可用值: this-thread | all-threads | while-stepping

       -r <regular-expression> ( --step-over-regexp <regular-expression> )
            # 一个正则表达式，它定义了在 step-in 时不暂停的函数的名称

       -t <function-name> ( --step-in-target <function-name> )
            # 直接调用的函数的名称，step in 应该在 step into 时暂停

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

## thread step-inst-over

```bash
(lldb) help thread step-inst-over
     # 汇编指令级别的单步执行，会跨过汇编函数的调用
     # 除非指定，否则默认为当前线程

Syntax: thread step-inst-over <cmd-options> [<thread-id>]

Command Options Usage:
  thread step-inst-over [-c <count>] [-e <linenum>] [-m <run-mode>] [-a <boolean>] [-t <function-name>] [-A <boolean>] [-r <regular-expression>] [<thread-id>]

       -A <boolean> ( --step-out-avoids-no-debug <boolean> )
            # 一个布尔值，如果为 true，则跳出函数时将继续跳出，直到它遇到一个带有调试信息的函数

       -a <boolean> ( --step-in-avoids-no-debug <boolean> )
            # 一个布尔值，用于设置在单步执行函数时，是否将单步执行没有调试信息的函数

       -c <count> ( --count <count> )
            # 执行步进操作的次数 - 目前仅支持 step-inst 和 next-inst

       -e <linenum> ( --end-linenumber <linenum> )
            # 要暂停步进的行号 - 默认为下一行，仅支持 step-in 和 step-over
            # 你还可以传递字符串 'block' 以步进到当前 block 的末尾
            # 这特别适合与 --step-target 结合使用，以逐步执行复杂的调用序列

       -m <run-mode> ( --run-mode <run-mode> )
            # 确定在单步执行当前线程的同时，如何运行其他线程
            # 可用值: this-thread | all-threads | while-stepping

       -r <regular-expression> ( --step-over-regexp <regular-expression> )
            # 一个正则表达式，它定义了在 step-in 时不暂停的函数的名称

       -t <function-name> ( --step-in-target <function-name> )
            # 直接调用的函数的名称，step in 应该在 step into 时暂停

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

## thread step-out

```bash
(lldb) help thread step-out
     # 执行完当前栈帧，并在返回后暂停
     # 除非指定，否则默认为当前线程

Syntax: thread step-out <cmd-options> [<thread-id>]

Command Options Usage:
  thread step-out [-c <count>] [-e <linenum>] [-m <run-mode>] [-a <boolean>] [-t <function-name>] [-A <boolean>] [-r <regular-expression>] [<thread-id>]

       -A <boolean> ( --step-out-avoids-no-debug <boolean> )
            # 一个布尔值，如果为 true，则跳出函数时将继续跳出，直到它遇到一个带有调试信息的函数

       -a <boolean> ( --step-in-avoids-no-debug <boolean> )
            # 一个布尔值，用于设置在单步执行函数时，是否将单步执行没有调试信息的函数

       -c <count> ( --count <count> )
            # 执行步进操作的次数 - 目前仅支持 step-inst 和 next-inst

       -e <linenum> ( --end-linenumber <linenum> )
            # 要暂停步进的行号 - 默认为下一行，仅支持 step-in 和 step-over
            # 你还可以传递字符串 'block' 以步进到当前 block 的末尾
            # 这特别适合与 --step-target 结合使用，以逐步执行复杂的调用序列

       -m <run-mode> ( --run-mode <run-mode> )
            # 确定在单步执行当前线程的同时，如何运行其他线程
            # 可用值: this-thread | all-threads | while-stepping

       -r <regular-expression> ( --step-over-regexp <regular-expression> )
            # 一个正则表达式，它定义了在 step-in 时不暂停的函数的名称

       -t <function-name> ( --step-in-target <function-name> )
            # 直接调用的函数的名称，step in 应该在 step into 时暂停

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

## thread step-over

```bash
(lldb) help thread step-over
     # 源码级别的单步执行，会跨过函数或方法的调用
     # 除非指定，否则默认为当前线程

Syntax: thread step-over <cmd-options> [<thread-id>]

Command Options Usage:
  thread step-over [-c <count>] [-e <linenum>] [-m <run-mode>] [-a <boolean>] [-t <function-name>] [-A <boolean>] [-r <regular-expression>] [<thread-id>]

       -A <boolean> ( --step-out-avoids-no-debug <boolean> )
            # 一个布尔值，如果为 true，则跳出函数时将继续跳出，直到它遇到一个带有调试信息的函数

       -a <boolean> ( --step-in-avoids-no-debug <boolean> )
            # 一个布尔值，用于设置在单步执行函数时，是否将单步执行没有调试信息的函数

       -c <count> ( --count <count> )
            # 执行步进操作的次数 - 目前仅支持 step-inst 和 next-inst

       -e <linenum> ( --end-linenumber <linenum> )
            # 要暂停步进的行号 - 默认为下一行，仅支持 step-in 和 step-over
            # 你还可以传递字符串 'block' 以步进到当前 block 的末尾
            # 这特别适合与 --step-target 结合使用，以逐步执行复杂的调用序列

       -m <run-mode> ( --run-mode <run-mode> )
            # 确定在单步执行当前线程的同时，如何运行其他线程
            # 可用值: this-thread | all-threads | while-stepping

       -r <regular-expression> ( --step-over-regexp <regular-expression> )
            # 一个正则表达式，它定义了在 step-in 时不暂停的函数的名称

       -t <function-name> ( --step-in-target <function-name> )
            # 直接调用的函数的名称，step in 应该在 step into 时暂停

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

## thread step-scripted

```bash
(lldb) help thread step-scripted
     # 按照 -C 选项中传递的脚本类的指示执行单步操作
     # 你还可以指定将用于填充 SBStructuredData 字典的键(-k)值(-v)对，该字典将传递给实现执行单步脚本的类的构造函数
     # 有关更多详细信息，请参阅 Python Reference

Syntax: thread step-scripted <cmd-options> [<thread-id>]

Command Options Usage:
  thread step-scripted -C <python-class> [-k <none>] [-v <none>] [-c <count>] [-e <linenum>] [-m <run-mode>] [-a <boolean>] [-t <function-name>] [-A <boolean>] [-r <regular-expression>] [<thread-id>]

       -A <boolean> ( --step-out-avoids-no-debug <boolean> )
            # 一个布尔值，如果为 true，则跳出函数时将继续跳出，直到它遇到一个带有调试信息的函数

       -C <python-class> ( --script-class <python-class> )
            # 要管理单步脚本的类的名称

       -a <boolean> ( --step-in-avoids-no-debug <boolean> )
            # 一个布尔值，用于设置在单步执行函数时，是否将单步执行没有调试信息的函数

       -c <count> ( --count <count> )
            # 执行步进操作的次数 - 目前仅支持 step-inst 和 next-inst

       -e <linenum> ( --end-linenumber <linenum> )
            # 要暂停步进的行号 - 默认为下一行，仅支持 step-in 和 step-over
            # 你还可以传递字符串 'block' 以步进到当前 block 的末尾
            # 这特别适合与 --step-target 结合使用，以逐步执行复杂的调用序列

       -k <none> ( --structured-data-key <none> )
            # 传递给单步脚本实现的键值对中的键
            # 键值对可以被指定多次

       -m <run-mode> ( --run-mode <run-mode> )
            # 确定在单步执行当前线程的同时，如何运行其他线程
            # 可用值: this-thread | all-threads | while-stepping

       -r <regular-expression> ( --step-over-regexp <regular-expression> )
            # 一个正则表达式，它定义了在 step-in 时不暂停的函数的名称

       -t <function-name> ( --step-in-target <function-name> )
            # 直接调用的函数的名称，step in 应该在 step into 时暂停

       -v <none> ( --structured-data-value <none> )
            # 传递给单步脚本实现的键值对中的值(对应前一个键)
            # 键值对可以被指定多次

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

## thread until

```bash
(lldb) help thread until 
     # 继续执行直到当前线程或指定线程到达指定行号或指定地址
     # 作为安全措施，从当前函数返回时也会暂停
     # 目标行号​​作为参数给出，如果提供了多个行号，则当第一个行号被命中时，执行将暂停

Syntax: thread until <cmd-options> <linenum>

Command Options Usage:
  thread until [-a <address-expression>] [-f <frame-index>] [-m <run-mode>] [-t <thread-index>] <linenum>

       -a <address-expression> ( --address <address-expression> )
            # 运行直到到达指定的地址，或离开当前函数
            # 可以指定多次

       -f <frame-index> ( --frame <frame-index> )
            # 用于 until 命令的栈帧的栈帧索引，默认为 0

       -m <run-mode> ( --run-mode <run-mode> )
            # 确定如何在单步执行时运行其他线程
            # 可用值: this-thread | all-threads

       -t <thread-index> ( --thread <thread-index> )
            # 用于 until 命令的线程的线程索引

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

# type

```bash
(lldb) help type
     # 用于在类型系统(type system)上操作的命令

Syntax: type [<sub-command-options>]

The following subcommands are supported:

      category     # 对类型的类别进行操作的命令
      filter       # 对类型的过滤器进行操作的命令
      format       # 用于自定义值的显示格式的命令
      lookup       # 在当前 target 中查找类型和声明，遵循特定于语言的命名约定
     			   # 期望使用原始输入(请参阅 'help raw-input')
      summary      # 用于编辑变量摘要显示格式的命令
      synthetic    # 用于操作合成提供程序类型表示的命令

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

## type category

```bash
(lldb) help type category
     # 对类型的类别进行操作的命令

Syntax: type category [<sub-command-options>]

The following subcommands are supported:

      define     # 定义一个新类别作为格式化程序的源
      delete     # 删除指定的类别及其相关的格式化程序
      disable    # 禁用(一个作为格式化程序的源)的类别
      enable     # 启用一个类别(以作为格式化程序的源)
      list       # 提供所有现有类别的列表

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

### type category define

```bash
(lldb) help type category define
     # 定义一个新类别作为格式化程序的源

Syntax: type category define <cmd-options> <name> [<name> [...]]

Command Options Usage:
  type category define [-e] [-l <source-language>] <name> [<name> [...]]

       -e ( --enabled )
            # 如果指定此选项，则此类别将在创建后被启用

       -l <source-language> ( --language <source-language> )
            # 指定此类别支持的语言

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

### type category delete

```bash
(lldb) help type category delete
     # 删除指定的类别及其相关的格式化程序

Syntax: type category delete <name> [<name> [...]]
```

### type category disable

```bash
(lldb) help type category disable
     # 禁用(一个作为格式化程序的源)的类别

Syntax: type category disable <cmd-options> <name> [<name> [...]]

Command Options Usage:
  type category disable [-l <source-language>] <name> [<name> [...]]

       -l <source-language> ( --language <source-language> )
            # 禁用指定语言的类别

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

### type category enable

```bash
(lldb) help type category enable
     # 启用一个类别(以作为格式化程序的源)

Syntax: type category enable <cmd-options> <name> [<name> [...]]

Command Options Usage:
  type category enable [-l <source-language>] <name> [<name> [...]]

       -l <source-language> ( --language <source-language> )
            # 启用指定语言的类别

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

### type category list

```bash
(lldb) help type category list
     # 提供所有现有类别的列表

Syntax: type category list [<name>]
```

## type filter

```bash
(lldb) help type filter
     # 对类型的过滤器进行操作的命令

Syntax: type synthetic [<sub-command-options>]

The following subcommands are supported:

      add       # 为指定的类型添加新的过滤器
      clear     # 删除所有现有的过滤器
      delete    # 删除指定类型的指定过滤器
      list      # 显示当前过滤器的列表

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

### type filter add

```bash
(lldb) help type filter add
     # 为指定的类型添加新的过滤器

Syntax: type filter add <cmd-options> <name> [<name> [...]]

Command Options Usage:
  type filter add [-prx] [-C <boolean>] [-w <name>] [-c <expr-path>] <name> [<name> [...]]

       -C <boolean> ( --cascade <boolean> )
            # 如果为 true，则通过 typedef 链级联

       -c <expr-path> ( --child <expr-path> )
            # 在综合视图(synthetic view)中包含此表达式路径

       -p ( --skip-pointers )
            # 不要对指针类型的对象(pointers-to-type object)使用此格式
            # 即，不要对指定类型的值的指针使用此格式

       -r ( --skip-references )
            # 不要对引用类型的对象(references-to-type object)使用此格式
            # 即，不要对指定类型的值的引用使用此格式

       -w <name> ( --category <name> )
            # 将此过滤器添加到给定的类别，而不是默认的类别

       -x ( --regex )
            # 类型名称实际上是正则表达式

# 以下 'type filter add' 的示例，引用此代码片段以获取上下文:

class Foo {
    int a;
    int b;
    int c;
    int d;
    int e;
    int f;
    int g;
    int h;
    int i;
}
Foo my_foo;

# 添加一个简单的过滤器:

# 生成仅显示 my_foo.a 和 my_foo.g 的输出
(lldb) type filter add --child a --child g Foo
(lldb) frame variable my_foo

# my_foo 的其他子项 (b, c, d, e, f, h, i) 可以通过显式指定的方式来获取:
(lldb) frame variable my_foo.b my_foo.c my_foo.i

# frame variable 上的格式化选项 --raw 会绕过过滤器，显示 my_foo 的所有子项，就好像没有定义过滤器一样:
(lldb) frame variable my_foo --raw

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

### type filter clear

```bash
(lldb) help type filter clear
     # 删除所有现有的过滤器

Syntax: type filter clear <cmd-options>

Command Options Usage:
  type filter clear [-a]

       -a ( --all )
            # 删除所有类别的过滤器
```

### type filter delete

```bash
(lldb) help type filter delete
     # 删除指定类型的指定过滤器

Syntax: type filter delete <cmd-options> <name>

Command Options Usage:
  type filter delete [-a] <name>
  type filter delete [-w <name>] <name>
  type filter delete [-l <source-language>] <name>

       -a ( --all )
            # 从所有的类别中删除指定的过滤器

       -l <source-language> ( --language <source-language> )
            # 从指定语言的类别中删除指定的过滤器

       -w <name> ( --category <name> )
            # 从指定的类别中删除指定的过滤器

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

### type filter list

```bash
(lldb) help type filter list
     # 显示当前过滤器的列表

Syntax: type filter list <cmd-options> [<name>]

Command Options Usage:
  type filter list [-w <name>] [<name>]
  type filter list [-l <source-language>] [<name>]

       -l <source-language> ( --language <source-language> )
            # 仅显示指定语言的过滤器列表

       -w <name> ( --category-regex <name> )
            # 仅显示与此类别匹配的过滤器列表

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

## type format

```bash
(lldb) help type format
     # 用于自定义值的显示格式的命令

Syntax: type format [<sub-command-options>]

The following subcommands are supported:

      add       # 为指定的类型添加新的格式样式
      clear     # 删除所有现有的格式样式
      delete    # 删除指定类型的指定格式样式
      info      # 此命令执行指定的表达式，并显示将以哪种格式样式应用于表达式的结果值(如果表达式有结果值的话)
     			# 期望使用原始输入(请参阅 'help raw-input')
      list      # 显示当前格式样式列表

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

### type format add

```bash
(lldb) help type format add
     # 为指定的类型添加新的格式样式

Syntax: type format add <cmd-options> <name> [<name> [...]]

Command Options Usage:
  type format add [-prx] [-f <format>] [-C <boolean>] [-w <name>] <name> [<name> [...]]
  type format add [-prx] [-C <boolean>] [-w <name>] [-t <name>] <name> [<name> [...]]

       -C <boolean> ( --cascade <boolean> )
            # 如果为 true，则通过 typedef 链级联

       -f <format> ( --format <format> )
            # 指定用于显示的格式

       -p ( --skip-pointers )
            # 不要对指针类型的对象(pointers-to-type object)使用此格式
            # 即，不要对指定类型的值的指针使用此格式

       -r ( --skip-references )
            # 不要对引用类型的对象(references-to-type object)使用此格式
            # 即，不要对指定类型的值的引用使用此格式

       -t <name> ( --type <name> )
            # 格式化变量，就好像它们属于此种类型一样

       -w <name> ( --category <name> )
            # 将此格式样式添加到给定的类别，而不是默认的类别

       -x ( --regex )
            # 类型名称实际上是正则表达式

# 以下 'type format add' 的示例，引用此代码片段以获取上下文:

typedef int Aint;
typedef float Afloat;
typedef Aint Bint;
typedef Afloat Bfloat;

Aint ix = 5;
Bint iy = 5;

Afloat fx = 3.14;
BFloat fy = 3.14;

# 添加默认格式:
(lldb) type format add -f hex AInt
# 因为没有可用于 Bint 的格式化程序，所以使用用于 Aint 的格式化程序，因此会输出 iy 的十六进制显示
(lldb) frame variable iy

# 为了防止出现上面这种情况，请使用级联选项 '-C no' 来防止对 typedef 链进行级联:
(lldb) type format add -f hex -C no AInt

# 同理可得:
# 所有浮点值和浮点引用现在都格式化为十六进制，但是指向浮点的指针并没有被格式化为十六进制
# 它也不会更改 Afloat 和 Bfloat 对象的默认显示
(lldb) type format add -f hex -C no float -p

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

### type format clear

```bash
(lldb) help type format clear
     # 删除所有现有的格式样式

Syntax: type format clear <cmd-options>

Command Options Usage:
  type format clear [-a]

       -a ( --all )
            # 删除所有类别的格式样式
```

### type format delete

```bash
(lldb) help type format delete
     # 删除指定类型的指定格式样式

Syntax: type format delete <cmd-options> <name>

Command Options Usage:
  type format delete [-a] <name>
  type format delete [-w <name>] <name>
  type format delete [-l <source-language>] <name>

       -a ( --all )
            # 从所有的类别中删除指定的格式样式

       -l <source-language> ( --language <source-language> )
            # 从指定语言的类别中删除指定的格式样式

       -w <name> ( --category <name> )
            # 从指定的类别中删除指定的格式样式

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

### type format info

```bash
(lldb) help type format info
     # 此命令执行指定的表达式，并显示将以哪种格式样式应用于表达式的结果值(如果表达式有结果值的话)
     # 期望使用原始输入(请参阅 'help raw-input')

Syntax: type format info <expr>
```

### type format list

```bash
(lldb) help type format list
     # 显示当前格式样式列表

Syntax: type format list <cmd-options> [<name>]

Command Options Usage:
  type format list [-w <name>] [<name>]
  type format list [-l <source-language>] [<name>]

       -l <source-language> ( --language <source-language> )
            # 仅显示指定语言的格式样式列表

       -w <name> ( --category-regex <name> )
            # 仅显示与此类别匹配的格式样式列表

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

## type lookup

```bash
(lldb) help type lookup
     # 在当前 target 中查找类型和声明，遵循特定于语言的命名约定
     # 期望使用原始输入(请参阅 'help raw-input')

Syntax: type lookup <type-specifier>

Command Options Usage:
  type lookup [-h] [-l <source-language>]

       -h ( --show-help )
            # 显示该类型的可用帮助

       -l <source-language> ( --language <source-language> )
            # 在指定的语言中搜索该类型(即，该类型的搜索范围)

# 对于 Swift，除了简单的类型名称(如 String、Int、NSObject、...)之外，还可以提供:
# 1. mangling 的类型名称(例如 _TtSi)
# 2. 函数的名称，即使该函数名称存在多个重载
# 3. 操作符的名称
# 4. 当前 target 中可用模块的名称，这将打印该模块中可用的所有类型和声明

# 重要提示:
# 因为这个命令需要原始输入，所以如果你使用任何命令选项，则你必须在命令选项的末尾和原始输入的开始之间使用 ' -- ' 分隔
```

## type summary

```bash
(lldb) help type summary
     # 用于编辑变量摘要显示格式的命令

Syntax: type summary [<sub-command-options>]

The following subcommands are supported:

      add       # 为指定的类型添加新的摘要样式
      clear     # 删除所有现有的摘要样式
      delete    # 删除指定类型的指定摘要样式
      info      # 此命令执行指定的表达式，并显示将以哪种摘要样式应用于表达式的结果值(如果表达式有结果值的话)
     			# 期望使用原始输入(请参阅 'help raw-input')
      list      # 显示当前摘要样式列表

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

### type summary add

```bash
(lldb) help type summary add
     # 为指定的类型添加新的摘要样式

Syntax: type summary add <cmd-options> <name> [<name> [...]]

Command Options Usage:
  type summary add -c [-Oprvx] [-C <boolean>] [-w <name>] <name> [<name> [...]]
  type summary add [-ehprvx] -s <summary-string> [-C <boolean>] [-w <name>] [-n <name>] <name> [<name> [...]]
  type summary add [-Pehprvx] [-C <boolean>] [-w <name>] [-n <name>] [-F <python-function>] [-o <python-script>] <name> [<name> [...]]

       -C <boolean> ( --cascade <boolean> )
            # 如果为 true，则通过 typedef 链级联

       -F <python-function> ( --python-function <python-function> )
            # 指定用于此类型的 Python 函数的名称

       -O ( --omit-names )
            # 如果为 true，则在摘要显示中省略值的名称

       -P ( --input-python )
            # 手动输入要用于此类型的 Python 代码

       -c ( --inline-children )
            # 如果为 true，则将所有子项的值内联到摘要字符串中

       -e ( --expand )
            # 展开聚合数据类型，以在单独的行上显示子项

       -h ( --hide-empty )
            # 不要展开没有子项的聚合数据类型

       -n <name> ( --name <name> )
            # 此摘要字符串的名称

       -o <python-script> ( --python-script <python-script> )
            # 提供一个单行 Python 脚本作为命令的一部分

       -p ( --skip-pointers )
            # 不要对指针类型的对象(pointers-to-type object)使用此格式
            # 即，不要对指定类型的值的指针使用此格式

       -r ( --skip-references )
            # 不要对引用类型的对象(references-to-type object)使用此格式
            # 即，不要对指定类型的值的引用使用此格式

       -s <summary-string> ( --summary-string <summary-string> )
            # 用于显示文本和对象内容的摘要字符串

       -v ( --no-value )
            # 对于此种类型，不显示值，只显示摘要

       -w <name> ( --category <name> )
            # 将此摘要样式添加到给定的类别，而不是默认的类别

       -x ( --regex )
            # 类型名称实际上是正则表达式

# 以下 'type summary add' 的示例，引用此代码片段以获取上下文:

struct JustADemo
{
    int* ptr;
    float value;
    JustADemo(int p = 1, float v = 0.1) : ptr(new int(p)), value(v) {}
};
JustADemo demo_instance(42, 3.14);

typedef JustADemo NewDemo;
NewDemo new_demo_instance(42, 3.14);

# 之后用 'frame variable' 或 'expression' 打印 demo_instance，将会显示 "the answer is 42"
(lldb) type summary add --summary-string "the answer is ${*var.ptr}" JustADemo

# 之后用 'frame variable' 或 'expression' 打印 demo_instance，将会显示 "the answer is 42 and the question is 3.14"
(lldb) type summary add --summary-string "the answer is ${*var.ptr}, and the question is ${var.value}" JustADemo

# 或者，你可以为所有指向整数的指针定义格式，并在格式化 JustADemo 时依赖它以获得相同的结果:
(lldb) type summary add --summary-string "${var%V} -> ${*var}" "int *"
(lldb) type summary add --summary-string "the answer is ${var.ptr}, and the question is ${var.value}" JustADemo

# 类型摘要会自动应用于派生的 typedef，因此上面的示例适用于 JustADemo 和 NewDemo
# 级联选项可用于抑制此行为，该摘要现在将用于 JustADemo 的值而不是 NewDemo 的值:
(lldb) type summary add --summary-string "${var.ptr}, ${var.value}, {${var.byte}}" JustADemo -C no

# 默认情况下，会显示对指定类型的值的指针和引用的摘要
# 使用 -p 选项可以抑制对指定类型的值的指针的摘要
# 使用 -r 选项可以抑制对指定类型的值的引用的摘要
(lldb) type summary add -p -r --summary-string "${var.ptr}, ${var.value}, {${var.byte}}" JustADemo

# 通过传递 -c 选项，可以推断出包含类型中所有字段的单行摘要，而无需提供显式的摘要字符串:
(lldb) type summary add -c JustADemo
(lldb) frame variable demo_instance (ptr=<address>, value=3.14)

# 类型摘要通常会抑制单个字段的嵌套显示
# 如果要提供摘要以补充默认结构，则请添加 -e 选项:
(lldb) type summary add -e --summary-string "*ptr = ${*var.ptr}" JustADemo

# 现在，在显示 JustADemo 的值时，会显示 int*，然后是标准的 LLDB 子序列，每行一个:

*ptr = 42 {
  ptr = <address>
  value = 3.14
}

# 你还可以添加用 Python 编写的摘要
# 这些脚本使用 LLDB 的公共 API，从变量中收集信息并生成有意义的摘要
# 如果要启动多行脚本，则请使用 -P 选项
# 函数声明将与描述这两个参数的注释一起显示
# 在单独的一行中使用单词 'DONE' 结束脚本
(lldb) type summary add JustADemo -P
def function (valobj,internal_dict):
"""valobj: an SBValue which you want to provide a summary for internal_dict: an LLDB support object not to be used"""
    value = valobj.GetChildMemberWithName('value');
    return 'My value is ' + value.GetValue();
    DONE

# 或者，如果要提供简单的单行 Python 脚本，则可以使用 -o 选项:
(lldb) type summary add JustADemo -o "value = valobj.GetChildMemberWithName('value'); return 'My value is ' + value.GetValue();"

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

### type summary clear

```bash
(lldb) help type summary clear
     # 删除所有现有的摘要样式

Syntax: type summary clear <cmd-options>

Command Options Usage:
  type summary clear [-a]

       -a ( --all )
            # 删除所有类别的摘要样式
```

### type summary delete

```bash
(lldb) help type summary delete
     # 删除指定类型的指定摘要样式

Syntax: type summary delete <cmd-options> <name>

Command Options Usage:
  type summary delete [-a] <name>
  type summary delete [-w <name>] <name>
  type summary delete [-l <source-language>] <name>

       -a ( --all )
            # 从所有的类别中删除指定的摘要样式

       -l <source-language> ( --language <source-language> )
            # 从指定语言的类别中删除指定的摘要样式

       -w <name> ( --category <name> )
            # 从指定的类别中删除指定的摘要样式

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

### type summary info

```bash
(lldb) help type summary info
     # 此命令执行指定的表达式，并显示将以哪种摘要样式应用于表达式的结果值(如果表达式有结果值的话)
     # 期望使用原始输入(请参阅 'help raw-input')

Syntax: type summary info <expr>
```

### type summary list

```bash
(lldb) help type summary list
     # 显示当前摘要样式列表

Syntax: type summary list <cmd-options> [<name>]

Command Options Usage:
  type summary list [-w <name>] [<name>]
  type summary list [-l <source-language>] [<name>]

       -l <source-language> ( --language <source-language> )
            # 仅显示指定语言的摘要样式列表

       -w <name> ( --category-regex <name> )
            # 仅显示与此类别匹配的摘要样式列表

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

## type synthetic

```bash
(lldb) help type synthetic
     # 用于操作合成提供程序类型表示的命令

Syntax: type synthetic [<sub-command-options>]

The following subcommands are supported:

      add       # 为指定的类型添加新的合成提供程序(synthetic provider)
      clear     # 删除所有现有的合成提供程序(synthetic provider)
      delete    # 删除指定类型的指定合成提供程序(synthetic provider)
      info      # 此命令执行指定的表达式，并显示将以哪种合成提供程序(synthetic provider)应用于表达式的结果值(如果表达式有结果值的话)
     			# 期望使用原始输入(请参阅 'help raw-input')
      list      # 显示当前合成提供程序(synthetic provider)列表

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

### type synthetic add

```bash
(lldb) help type synthetic add
     # 为指定的类型添加新的合成提供程序(synthetic provider)

Syntax: type synthetic add <cmd-options> <name> [<name> [...]]

Command Options Usage:
  type synthetic add [-prx] [-C <boolean>] [-w <name>] <name> [<name> [...]]
  type synthetic add [-prx] [-C <boolean>] [-w <name>] [-l <python-class>] <name> [<name> [...]]
  type synthetic add [-Pprx] [-C <boolean>] [-w <name>] <name> [<name> [...]]

       -C <boolean> ( --cascade <boolean> )
            # 如果为 true，则通过 typedef 链级联

       -P ( --input-python )
            # 输入 Python 代码以生成提供合成子元素的类

       -l <python-class> ( --python-class <python-class> )
            # 使用这个 Python 类来生成合成的子元素

       -p ( --skip-pointers )
            # 不要对指针类型的对象(pointers-to-type object)使用此格式
            # 即，不要对指定类型的值的指针使用此格式

       -r ( --skip-references )
            # 不要对引用类型的对象(references-to-type object)使用此格式
            # 即，不要对指定类型的值的引用使用此格式

       -w <name> ( --category <name> )
            # 将此合成提供程序(synthetic provider)添加到给定的类别，而不是默认的类别

       -x ( --regex )
            # 类型名称实际上是正则表达式

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

### type synthetic clear

```bash
(lldb) help type synthetic clear
     # 删除所有现有的合成提供程序(synthetic provider)

Syntax: type synthetic clear <cmd-options>

Command Options Usage:
  type synthetic clear [-a]

       -a ( --all )
            # 删除所有类别的合成提供程序(synthetic provider)
```

### type synthetic delete

```bash
(lldb) help type synthetic delete
     # 删除指定类型的指定合成提供程序(synthetic provider)

Syntax: type synthetic delete <cmd-options> <name>

Command Options Usage:
  type synthetic delete [-a] <name>
  type synthetic delete [-w <name>] <name>
  type synthetic delete [-l <source-language>] <name>

       -a ( --all )
            # 从所有的类别中删除指定的合成提供程序(synthetic provider)

       -l <source-language> ( --language <source-language> )
            # 从指定语言的类别中删除指定的合成提供程序(synthetic provider)

       -w <name> ( --category <name> )
            # 从指定的类别中删除指定的合成提供程序(synthetic provider)

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

### type synthetic info

```bash
(lldb) help type synthetic info
     # 此命令执行指定的表达式，并显示将以哪种合成提供程序(synthetic provider)应用于表达式的结果值(如果表达式有结果值的话)
     # 期望使用原始输入(请参阅 'help raw-input')

Syntax: type synthetic info <expr>
```

### type synthetic list

```bash
(lldb) help type synthetic list
     # 显示当前合成提供程序(synthetic provider)列表

Syntax: type synthetic list <cmd-options> [<name>]

Command Options Usage:
  type synthetic list [-w <name>] [<name>]
  type synthetic list [-l <source-language>] [<name>]

       -l <source-language> ( --language <source-language> )
            # 仅显示指定语言的合成提供程序(synthetic provider)列表

       -w <name> ( --category-regex <name> )
            # 仅显示与此类别匹配的合成提供程序(synthetic provider)列表

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

# version

```bash
(lldb) help version
     # 用于显示 LLDB 调试器的版本

Syntax: version
```

# watchpoint

```bash
(lldb) help watchpoint
     # 用于操作内存断点的命令

Syntax: watchpoint <subcommand> [<command-options>]

The following subcommands are supported:

      command    # 用于添加、删除和列出在命中内存断点时执行的 LLDB 命令的命令
      delete     # 删除指定的内存断点
      			 # 如果没有指定任何内存断点，则将所有内存断点全部删除
      disable    # 禁用指定的内存断点，而不删除它们
                 # 如果没有指定任何内存断点，则将所有内存断点全部禁用
      enable     # 启用指定的内存断点
      			 # 如果没有指定任何内存断点，则将所有内存断点全部启用
      ignore     # 设置在命中内存断点之前，跳过此内存断点的次数
      			 # 如果没有指定任何内存断点，则将作用于所有内存断点
      list       # 以可配置的详细程度列出部分或全部内存断点
      modify     # 修改可执行文件中一个或一组内存断点上的选项
				 # 如果没有指定任何内存断点，则修改最后创建的内存断点
				 # 传递一个空的参数可以清除已做的修改
      set        # 用于设置内存断点的命令

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

## watchpoint command

```bash
(lldb) help watchpoint command
     # 用于添加、删除和列出在命中内存断点时执行的 LLDB 命令的命令

Syntax: command <sub-command> [<sub-command-options>] <watchpoint-id>

The following subcommands are supported:

      add       # 将一组 LLDB 命令添加到内存断点中，以便在命中内存断点时执行
      delete    # 从指定的内存断点中删除已添加的 LLDB 命令
      list      # 列出在命中指定的内存断点时，要执行的脚本或命令

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

### watchpoint command add

```bash
(lldb) help watchpoint command add
     # 将一组 LLDB 命令添加到内存断点中，以便在命中内存断点时执行

Syntax: watchpoint command add <cmd-options> <watchpt-id>

Command Options Usage:
  watchpoint command add [-o <one-line-command>] [-s <none>] [-e <boolean>] <watchpt-id>
  watchpoint command add [-F <python-function>] [-s <none>] [-e <boolean>] <watchpt-id>

       -F <python-function> ( --python-function <python-function> )
            # 指定 Python 函数的名称，以作为此内存断点的命令运行
            # 如果可能，请务必提供模块名称

       -e <boolean> ( --stop-on-error <boolean> )
            # 指定内存断点命令是否应在错误时终止执行

       -o <one-line-command> ( --one-liner <one-line-command> )
            # 内联指定的单行内存断点命令
            # 该命令一定要用引号括起来

       -s <none> ( --script-type <none> )
            # 指定命令的语言，如果没有指定任何语言，则使用 LLDB 命令解释器
            # 可用值: command | python | lua | default-script

# 关于输入内存断点命令的一般信息
------------------------------------------------------

# 此命令将在命中指定的内存断点时提示要执行的命令
# 每个命令都在 '> ' 提示符后在自己的行上输入，直到输入 'DONE' 结束

# 在输入时可能无法检测到语法错误，并且许多格式错误的命令在执行时可能会默默地失败
# 如果内存断点命令似乎没有被执行，则请仔细检查命令语法

# 注意:
# 完全可以按照在 debugger prompt 中的输入方式输入任何调试命令(Xcode 的调试区域就是一个 debugger prompt)
# 输入的命令数量没有限制，但是不要在每行输入一个以上的命令

# 有关 Python 内存断点命令的特殊信息
----------------------------------------------------

# 你可以输入一行或多行 Python，包括函数定义，或对(在代码执行时已导入的函数)的调用
# 当内存断点被命中时，单行内存断点命令将被 "按原样" 解释
# 多行 Python 代码将包装在生成的函数中，对该函数的调用将被附加到内存断点上

# 这个自动生成的函数传入二个参数:
# frame: 表示被命中的内存断点的帧的 lldb.SBFrame 对象
# wp:	 表示被命中的内存断点

# 当使用 --python-function 选项指定 Python 函数时，需要提供以模块名称开头的函数名称:
    --python-function myutils.watchpoint_callback

# 该函数本身必须具备以下函数原型:
def watchpoint_callback(frame, wp):
  # Your code goes here

# 这里的参数与上述传递给自动生成的函数的参数相同
# 请注意，因为调用此函数时不会更新全局变量 'lldb.frame'，所以请务必使用 'frame' 参数
# 'frame' 参数可以通过 frame.GetThread() 获取线程，线程可以通过 thread.GetProcess() 获取进程，进程可以通过 process.GetTarget() 获取 target

# 重要提示:
# 随着 Python 代码被收集到自动生成的函数中，访问全局变量时需要使用 'global' 关键字显式指定作用域
# 输入 Python 内存断点命令时，请务必使用正确的 Python 语法，包括缩进

# Python 单行内存断点命令的示例:

(lldb) watchpoint command add -s python 1
Enter your Python command(s). Type 'DONE' to end.
> print "Hit this watchpoint!"
> DONE

# 为了方便起见，这也适用于短的单行内存断点命令:

(lldb) watchpoint command add -s python 1 -o 'import time; print time.asctime()'
(lldb) run
Launching '.../a.out'  (x86_64)
(lldb) Fri Sep 10 12:17:45 2010
Process 21778 Stopped
* thread #1: tid = 0x2e03, 0x0000000100000de8 a.out`c + 7 at main.c:39, stop
reason = watchpoint 1.1, queue = com.apple.main-thread
  36
  37   	int c(int val)
  38   	{
  39 ->	    return val + 3;
  40   	}
  41
  42   	int main (int argc, char const *argv[])

# Python 多行内存断点命令的示例(使用函数定义):

(lldb) watchpoint command add -s python 1
Enter your Python command(s). Type 'DONE' to end.
> def watchpoint_output (wp_no):
>     out_string = "Hit watchpoint number " + repr (wp_no)
>     print out_string
>     return True
> watchpoint_output (1)
> DONE

# Python 多行内存断点命令的示例(使用 loose Python):

(lldb) watchpoint command add -s p 1
Enter your Python command(s). Type 'DONE' to end.
> global wp_count
> wp_count = wp_count + 1
> print "Hit this watchpoint " + repr(wp_count) + " times!"
> DONE

# 在这种情况下，因为存在对全局变量 'wp_count' 的引用，所以你还需要确保全局变量 'wp_count' 存在并已初始化:

(lldb) script
>>> wp_count = 0
>>> quit()

# 最后说明:
# 当没有语法错误时，出现没有生成内存断点命令的警告，可能表明函数已经声明但是从未被调用

----------------------------------------------------

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

### watchpoint command delete

```bash
(lldb) help watchpoint command delete
     # 从指定的内存断点中删除已添加的 LLDB 命令

Syntax: watchpoint command delete <watchpt-id>
```

### watchpoint command list

```bash
(lldb) help watchpoint command list
     # 列出在命中指定的内存断点时，要执行的脚本或命令

Syntax: watchpoint command list <watchpt-id>
```

## watchpoint delete

```bash
(lldb) help watchpoint delete
     # 删除指定的内存断点
     # 如果没有指定任何内存断点，则将所有内存断点全部删除

Syntax: watchpoint delete <cmd-options> [<watchpt-id | watchpt-id-list>]

Command Options Usage:
  watchpoint delete [-f] [<watchpt-id | watchpt-id-list>]

       -f ( --force )
            # 删除所有内存断点，而不查询确认

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

## watchpoint disable

```bash
(lldb) help watchpoint disable
     # 禁用指定的内存断点，而不删除它们
	 # 如果没有指定任何内存断点，则将所有内存断点全部禁用

Syntax: watchpoint disable [<watchpt-id | watchpt-id-list>]
```

## watchpoint enable

```bash
(lldb) help watchpoint enable
     # 启用指定的内存断点
     # 如果没有指定任何内存断点，则将所有内存断点全部启用

Syntax: watchpoint enable [<watchpt-id | watchpt-id-list>]
```

## watchpoint ignore

```bash
(lldb) help watchpoint ignore
     # 设置在命中内存断点之前，跳过此内存断点的次数
     # 如果没有指定任何内存断点，则将作用于所有内存断点

Syntax: watchpoint ignore <cmd-options> [<watchpt-id | watchpt-id-list>]

Command Options Usage:
  watchpoint ignore -i <count> [<watchpt-id | watchpt-id-list>]

       -i <count> ( --ignore-count <count> )
            # 设置在命中内存断点之前，跳过此内存断点的次数

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

## watchpoint list

```bash
(lldb) help watchpoint list
     # 以可配置的详细程度列出部分或全部内存断点

Syntax: watchpoint list <cmd-options> [<watchpt-id | watchpt-id-list>]

Command Options Usage:
  watchpoint list [-b] [<watchpt-id | watchpt-id-list>]
  watchpoint list [-f] [<watchpt-id | watchpt-id-list>]
  watchpoint list [-v] [<watchpt-id | watchpt-id-list>]

       -b ( --brief )
            # 简要描述内存断点(无位置信息)

       -f ( --full )
            # 给出内存断点及其位置信息的完整描述

       -v ( --verbose )
            # 解释我们所知道的关于内存断点的一切(用于调试调试器的 bug)

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

## watchpoint modify

```bash
(lldb) help watchpoint modify
     # 修改可执行文件中一个或一组内存断点上的选项
	 # 如果没有指定任何内存断点，则修改最后创建的内存断点
	 # 传递一个空的参数可以清除已做的修改

Syntax: watchpoint modify <cmd-options> [<watchpt-id | watchpt-id-list>]

Command Options Usage:
  watchpoint modify [-c <expr>] [<watchpt-id | watchpt-id-list>]

       -c <expr> ( --condition <expr> )
            # 仅当此条件表达式的计算结果为 true 时，内存断点才会暂停

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

## watchpoint set

```bash
(lldb) help watchpoint set
     # 用于设置内存断点的命令

Syntax: watchpoint set <subcommand> [<subcommand-options>]

The following subcommands are supported:

      expression    # 通过指定的表达式在指定的地址上设置内存断点
                    # 使用 '-w' 选项指定内存断点的类型，使用 '-s' 选项指定要监视的字节大小
                    # 如果未指定 '-w' 选项，则默认为写入
                    # 如果未指定 '-s' 选项，则默认为 target 的指针的字节大小
                    # 请注意，内存断点的硬件资源有限
                    # 如果内存断点设置失败，则请考虑禁用/删除现有的内存断点以释放资源
                    # 期望使用原始输入(请参阅 'help raw-input')
      variable      # 在指定的变量上设置内存断点
       				# 使用 '-w' 选项指定内存断点的类型，使用 '-s' 选项指定要监视的字节大小
       				# 如果未指定 '-w' 选项，则默认为写入
       				# 如果未指定 '-s' 选项，则默认为变量的字节大小
       				# 请注意，内存断点的硬件资源有限
       				# 如果内存断点设置失败，则请考虑禁用/删除现有的内存断点以释放资源
                    # 期望使用原始输入(请参阅 'help raw-input')

For more help on any particular subcommand, type 'help <command> <subcommand>'.
```

### watchpoint set expression

```bash
(lldb) help watchpoint set expression
     # 通过指定的表达式在指定的地址上设置内存断点
	 # 使用 '-w' 选项指定内存断点的类型，使用 '-s' 选项指定要监视的字节大小
	 # 如果未指定 '-w' 选项，则默认为写入
	 # 如果未指定 '-s' 选项，则默认为 target 的指针的字节大小
	 # 请注意，内存断点的硬件资源有限
	 # 如果内存断点设置失败，则请考虑禁用/删除现有的内存断点以释放资源
	 # 期望使用原始输入(请参阅 'help raw-input')

Syntax: watchpoint set expression <cmd-options> -- <expr>

Command Options Usage:
  watchpoint set expression [-w <watch-type>] [-s <byte-size>] -- <expr>
  watchpoint set expression <expr>

       -s <byte-size> ( --size <byte-size> )
            # 用于指定要监视的区域的字节数
            # 可用值: 1 | 2 | 4 | 8

       -w <watch-type> ( --watch <watch-type> )
            # 用于指定监视的类型
            # 可用值: read | write | read_write

# 示例:
# 对 'foo + 32' 所指向的地址处，1 个字节内存区域的写访问进行监视
(lldb) watchpoint set expression -w write -s 1 -- foo + 32

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

### watchpoint set variable

```bash
(lldb) help watchpoint set variable
     # 在指定的变量上设置内存断点
     # 使用 '-w' 选项指定内存断点的类型，使用 '-s' 选项指定要监视的字节大小
     # 如果未指定 '-w' 选项，则默认为写入
     # 如果未指定 '-s' 选项，则默认为变量的字节大小
     # 请注意，内存断点的硬件资源有限
     # 如果内存断点设置失败，则请考虑禁用/删除现有的内存断点以释放资源
	 # 期望使用原始输入(请参阅 'help raw-input')

Syntax: watchpoint set variable <cmd-options> <variable-name>

Command Options Usage:
  watchpoint set variable [-w <watch-type>] [-s <byte-size>] <variable-name>

       -s <byte-size> ( --size <byte-size> )
            # 用于指定要监视的区域的字节数
            # 可用值: 1 | 2 | 4 | 8

       -w <watch-type> ( --watch <watch-type> )
            # 用于指定监视的类型
            # 可用值: read | write | read_write

# 示例:
# 监视对变量 'my_global_var' 内存区域的读写访问，要监视的区域与 'my_global_var' 数据类型的字节大小相对应
(lldb) watchpoint set variable -w read_write my_global_var

# 此命令接受命令选项(options)和自由格式的参数(free-form arguments)
# 如果参数类似于选项说明符(即，参数以 - 或 -- 开头)，则必须在命令选项的结尾和参数的开头之间使用 ' -- '
```

# 对照表：命令的缩写形式 && 命令的规范形式

| 缩写形式 | 规范形式 | 所有等效的命令别名 |
| :-- | :-- | :-- |
| `add-dsym` | `target symbols add` | `add-dsym` |
| `attach` | `_regexp-attach` | `attach` |
| `b` | `_regexp-break` | `b` |
| `bt` | `_regexp-bt` | `bt` |
| `c` | `process continue` | `c`、`continue` |
| `call` | `expression --` | `call`、`p`、`print` |
| `continue` | `process continue` | `c`、`continue` |
| `detach` | `process detach` | `detach` |
| `di` | `disassemble` | `di`、`dis` |
| `dis` | `disassemble` | `di`、`dis` |
| `display` | `_regexp-display` | `display` |
| `down` | `_regexp-down` | `down` |
| `env` | `_regexp-env` | `env` |
| `exit` | `quit` | `exit`、`q` |
| `f` | `frame select` | `f` |
| `file` | `target create` | `file` |
| `finish` | `thread step-out` | `finish` |
| `image` | `target modules` | `image` |
| `j` | `_regexp-jump` | `j`、`jump` |
| `jump` | `_regexp-jump` | `j`、`jump` |
| `kill` | `process kill` | `kill` |
| `l` | `_regexp-list` | `l`、`list` |
| `list` | `_regexp-list` | `l`、`list` |
| `n` | `thread step-over` | `n`、`next` |
| `next` | `thread step-over` | `n`、`next` |
| `nexti` | `thread step-inst-over` | `nexti`、`ni` |
| `ni` | `thread step-inst-over` | `nexti`、`ni` |
| `p` | `expression --` | `call`、`p`、`print` |
| `parray` | `expression -Z %1 --` | `parray` |
| `po` | `expression -O --` | `po` |
| `poarray` | `expression -O -Z %1 --` | `poarray` |
| `print` | `expression --` | `call`、`p`、`print` |
| `q` | `quit` | `exit`、`q` |
| `r` | `process launch -X true --` | `r`、`run` |
| `rbreak` | `breakpoint set -r %1` | `rbreak` |
| `re` | `register` | `re` |
| `repl` | `expression -r –` | `repl` |
| `run` | `process launch -X true --` | `r`、`run` |
| `s` | `thread step-in` | `s`、`step` |
| `shell` | `platform shell -h --` | `shell` |
| `si` | `thread step-inst` | `si`、`stepi` |
| `sif` | `thread step-in -e block -t %1` | `sif` |
| `step` | `thread step-in` | `s`、`step` |
| `stepi` | `thread step-inst` | `si`、`stepi` |
| `t` | `thread select` | `t` |
| `tbreak` | `_regexp-tbreak` | `tbreak` |
| `undisplay` | `_regexp-undisplay` | `undisplay` |
| `up` | `_regexp-up` | `up` |
| `v` | `frame variable` | `v`、`var` |
| `var` | `frame variable` | `v`、`var` |
| `vo` | `frame variable -O` | `vo` |
| `x` | `memory read` | `x` |